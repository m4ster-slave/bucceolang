use crate::expr_types::*;
use crate::object::Object;
use crate::parser_error::{self, error, ParseError};
use crate::stmt_types::{ClassStmt, FunctionStmt, IfStmt, ReturnStmt, Stmt, VarStmt, WhileStmt};
use crate::token::TokenType;
use crate::Token;

/// A recursive descent parser that takes a list of tokens and generates an abstract syntax tree (AST).
///
/// The parser follows the grammar of the language to construct an AST representation
/// of the input code. It handles operator precedence and associativity through
/// a series of parsing methods.
pub struct Parser {
    /// The list of tokens generated by the scanner.
    tokens: Vec<Token>,
    /// The index of the current token being considered.
    current: usize,
    /// A flag indicating whether a parsing error has occurred.
    had_error: bool,
}

impl Parser {
    /// Creates a new `Parser` with the given list of tokens.
    ///
    /// # Arguments
    ///
    /// * `tokens` - A `Vec<Token>` representing the input tokens.
    pub fn new(tokens: Vec<Token>) -> Self {
        Parser {
            tokens,
            current: 0,
            had_error: false,
        }
    }

    /// Parses an expression according to the language's grammar.
    ///
    /// This method is the entry point for parsing expressions. It delegates
    /// to the `equality` method, which handles the lowest precedence operator.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` on success, or a `ParseError` if a
    /// parsing error occurs during the expression parsing.
    fn expression(&mut self) -> Result<Expr, ParseError> {
        self.assignment()
    }

    fn or(&mut self) -> Result<Expr, ParseError> {
        let mut expr = self.and()?;

        while self.match_token(TokenType::Or) {
            let operator = self.previous().clone();
            let right = self.and()?;

            expr = Expr::Logical(LogicalExpr {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            });
        }

        Ok(expr)
    }

    fn and(&mut self) -> Result<Expr, ParseError> {
        let mut expr = self.equality()?;

        while self.match_token(TokenType::And) {
            let operator = self.previous().clone();
            let right = self.equality()?;

            expr = Expr::Logical(LogicalExpr {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            });
        }

        Ok(expr)
    }

    fn assignment(&mut self) -> Result<Expr, ParseError> {
        let expr = self.or()?;

        if self.match_token(TokenType::Equal) {
            let equals = self.previous().clone();
            let value = self.assignment()?;

            match expr {
                Expr::Variable(var_expr) => {
                    return Ok(Expr::Assign(AssignExpr {
                        name: var_expr.name,
                        value: Box::new(value),
                    }))
                }
                Expr::PropertyAssignment(class_assignment) => {
                    return Ok(Expr::PropertyAssignment(PropertyAssignmentExpr {
                        object: class_assignment.object,
                        name: class_assignment.name,
                        value: Box::new(value),
                    }))
                }
                _ => return Err(error(&equals, "Invalid assignment target.".to_string())),
            }
        }

        Ok(expr)
    }

    /// Parses an equality expression (`==`, `!=`).
    ///
    /// This method parses a comparison expression and then checks for
    /// equality or inequality operators, building binary expression nodes
    /// as needed.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` representing the parsed equality
    /// expression, or a `ParseError` if an error occurs.
    fn equality(&mut self) -> Result<Expr, ParseError> {
        let mut expr = self.comparison()?;
        while self.match_tokens(&[TokenType::BangEqual, TokenType::EqualEqual]) {
            let operator = self.previous().clone();
            let right = self.comparison().inspect_err(|_| {
                self.had_error = true;
                self.synchronize();
            })?;
            expr = Expr::Binary(BinaryExpr {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            });
        }
        Ok(expr)
    }

    /// Parses a comparison expression (`>`, `>=`, `<`, `<=`).
    ///
    /// This method parses a term and then checks for comparison operators,
    /// building binary expression nodes as needed.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` representing the parsed comparison
    /// expression, or a `ParseError` if an error occurs.
    fn comparison(&mut self) -> Result<Expr, ParseError> {
        let mut expr = self.term()?;
        while self.match_tokens(&[
            TokenType::Greater,
            TokenType::GreaterEqual,
            TokenType::Less,
            TokenType::LessEqual,
        ]) {
            let operator = self.previous().clone();
            let right = self.term().inspect_err(|_| {
                self.had_error = true;
                self.synchronize();
            })?;
            expr = Expr::Binary(BinaryExpr {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            });
        }
        Ok(expr)
    }

    /// Parses an additive expression (`+`, `-`).
    ///
    /// This method parses a factor and then checks for additive operators,
    /// building binary expression nodes as needed.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` representing the parsed additive
    /// expression, or a `ParseError` if an error occurs.
    fn term(&mut self) -> Result<Expr, ParseError> {
        let mut expr = self.factor()?;
        while self.match_tokens(&[TokenType::Minus, TokenType::Plus]) {
            let operator = self.previous().clone();
            let right = self.factor().inspect_err(|_| {
                self.had_error = true;
                self.synchronize();
            })?;
            expr = Expr::Binary(BinaryExpr {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            });
        }
        Ok(expr)
    }

    /// Parses a multiplicative expression (`*`, `/`).
    ///
    /// This method parses a unary expression and then checks for multiplicative
    /// operators, building binary expression nodes as needed.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` representing the parsed multiplicative
    /// expression, or a `ParseError` if an error occurs.
    fn factor(&mut self) -> Result<Expr, ParseError> {
        let mut expr = self.unary()?;
        while self.match_tokens(&[TokenType::Slash, TokenType::Asterisk]) {
            let operator = self.previous().clone();
            let right = self.unary().inspect_err(|_| {
                self.had_error = true;
                self.synchronize();
            })?;
            expr = Expr::Binary(BinaryExpr {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            });
        }
        Ok(expr)
    }

    /// Parses a unary expression (`!`, `-`).
    ///
    /// This method checks for unary operators (`!` or `-`) and, if found,
    /// recursively parses the operand. Otherwise, it delegates to `primary`.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` representing the parsed unary
    /// expression or the result of `primary`, or a `ParseError` if an
    /// error occurs.
    fn unary(&mut self) -> Result<Expr, ParseError> {
        if self.match_tokens(&[TokenType::Bang, TokenType::Minus]) {
            let prefix = self.previous().clone();
            let operator = self.unary().inspect_err(|_| {
                self.had_error = true;
                self.synchronize();
            })?;
            return Ok(Expr::Unary(UnaryExpr {
                prefix,
                operator: Box::new(operator),
            }));
        }
        self.call()
    }

    /// Parses the highest precedence expressions: literals, grouping, and variables.
    ///
    /// This method handles boolean literals (`true`, `false`, `nil`), number
    /// and string literals, parenthesized expressions, and variable references.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` representing the parsed primary
    /// expression, or a `ParseError` if an error occurs (e.g., unexpected token).
    fn primary(&mut self) -> Result<Expr, ParseError> {
        if self.match_tokens(&[TokenType::False, TokenType::True, TokenType::Nil]) {
            return Ok(Expr::Literal(LiteralExpr {
                literal: self.previous().clone(),
            }));
        }
        if let TokenType::Number = &self.peek().token_type() {
            self.advance();
            return Ok(Expr::Literal(LiteralExpr {
                literal: self.previous().clone(),
            }));
        }
        if let TokenType::String = &self.peek().token_type() {
            self.advance();
            return Ok(Expr::Literal(LiteralExpr {
                literal: self.previous().clone(),
            }));
        }
        if let TokenType::Var = &self.peek().token_type() {
            self.advance();
            return Ok(Expr::Variable(VariableExpr {
                name: self.previous().clone(),
            }));
        }
        if self.match_token(TokenType::LeftParen) {
            let _paren_open = self.previous().clone();
            let expr = self.expression().inspect_err(|_| {
                self.had_error = true;
                self.synchronize();
            })?;
            if !self.check(&TokenType::RightParen) {
                let error =
                    parser_error::error(self.peek(), "Expected ')' after expression".into());
                self.had_error = true;
                self.synchronize();
                return Err(error);
            }
            self.advance();
            let _paren_close = self.previous().clone();
            return Ok(Expr::Grouping(GroupingExpr {
                _paren_open,
                expr: Box::new(expr),
                _paren_close,
            }));
        }
        // If none of the primary expression types match, it's a parsing error.
        let error = parser_error::error(self.peek(), "Expected expression".into());
        self.had_error = true;
        self.synchronize();
        Err(error)
    }

    /// Checks if the current token's type is one of the provided types and consumes it if it is.
    ///
    /// This method iterates through the given slice of `TokenType`s. If the
    /// current token matches any of these types, the parser advances to the
    /// next token, and the method returns `true`. Otherwise, it returns `false`
    /// without consuming the token.
    ///
    /// # Arguments
    ///
    /// * `types` - A slice of `TokenType`s to check against the current token.
    ///
    /// # Returns
    ///
    /// `true` if the current token's type is in the provided slice and was consumed,
    /// `false` otherwise.
    fn match_tokens(&mut self, types: &[TokenType]) -> bool {
        for t in types {
            if self.check(t) {
                self.advance();
                return true;
            }
        }
        false
    }

    /// Checks if the current token's type is the specified type and consumes it if it is.
    ///
    /// This is a convenience method for `match_tokens` when checking against a single type.
    ///
    /// # Arguments
    ///
    /// * `token_type` - The `TokenType` to check against the current token.
    ///
    /// # Returns
    ///
    /// `true` if the current token's type matches the specified type and was consumed,
    /// `false` otherwise.
    fn match_token(&mut self, token_type: TokenType) -> bool {
        if self.check(&token_type) {
            self.advance();
            return true;
        }
        false
    }

    /// Checks if the current token's type matches the given `TokenType` without consuming it.
    ///
    /// This method looks at the current token without advancing the parser.
    ///
    /// # Arguments
    ///
    /// * `token_type` - The `TokenType` to check against the current token.
    ///
    /// # Returns
    ///
    /// `true` if the current token's type matches the given type, `false` otherwise.
    fn check(&self, token_type: &TokenType) -> bool {
        if self.is_at_end() {
            return false;
        }

        self.peek().token_type() == token_type
    }

    /// Consumes the current token and advances the parser to the next token.
    ///
    /// If the parser is already at the end of the token stream, this method
    /// does nothing.
    ///
    /// # Returns
    ///
    /// A reference to the token that was just consumed (the token that was
    /// at the `current` position before the advance).
    fn advance(&mut self) -> &Token {
        if !self.is_at_end() {
            self.current += 1;
        }
        self.previous()
    }

    /// Checks if the parser has reached the end of the token stream.
    ///
    /// The end is indicated by the `TokenType::Eof`.
    ///
    /// # Returns
    ///
    /// `true` if the current token is `TokenType::Eof`, `false` otherwise.
    fn is_at_end(&self) -> bool {
        matches!(self.peek().token_type(), TokenType::Eof)
    }

    /// Returns a reference to the current token without consuming it.
    ///
    /// # Returns
    ///
    /// A reference to the `Token` at the current parser position.
    fn peek(&self) -> &Token {
        &self.tokens[self.current]
    }

    /// Returns a reference to the previously consumed token.
    ///
    /// This is the token that was at the `current` position before the last
    /// call to `advance`.
    ///
    /// # Returns
    ///
    /// A reference to the `Token` at the `current - 1` position.
    fn previous(&mut self) -> &Token {
        &self.tokens[self.current - 1]
    }

    /// Attempts to synchronize the parser after an error.
    ///
    /// This method discards tokens until it finds a token that is likely
    /// the start of a new statement, helping the parser recover from errors
    /// and continue parsing the rest of the input. It advances past a semicolon
    /// or until it encounters a keyword that typically starts a new statement.
    fn synchronize(&mut self) {
        self.advance(); // Advance past the token that caused the error

        while !self.is_at_end() {
            // If we see a semicolon, we've reached the end of the previous statement.
            if matches!(self.previous().token_type(), TokenType::Semicolon) {
                return;
            }

            // If we see a keyword that starts a new statement, we can likely
            // resume parsing from there.
            match &self.peek().token_type() {
                TokenType::Class
                | TokenType::Fn
                | TokenType::VarKeyword
                | TokenType::If
                | TokenType::While
                | TokenType::Print
                | TokenType::Return => return,
                _ => {
                    // Otherwise, consume the current token and continue searching.
                    self.advance();
                }
            }
        }
    }

    /// Consumes the current token if its type matches the expected `token_type`.
    ///
    /// If the current token's type matches `token_type`, the parser advances to the next token
    /// and returns a reference to the consumed token.
    /// If the current token's type does not match, a `ParseError` is returned with the
    /// provided `message`.
    ///
    /// # Arguments
    ///
    /// * `token_type`: The expected `TokenType` of the current token.
    /// * `message`: The error message to include in the `ParseError` if the token type
    ///   does not match.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing a reference to the consumed `Token` if the type matches,
    /// otherwise returns a `ParseError`.
    fn consume(&mut self, token_type: TokenType, message: &str) -> Result<&Token, ParseError> {
        if self.check(&token_type) {
            return Ok(self.advance());
        }
        Err(error(self.peek(), message.to_string()))
    }

    /// Parses an `if` statement.
    ///
    /// The structure of an `if` statement is:
    /// `if (condition) then_branch else else_branch`
    /// The `else` branch is optional.
    ///
    /// This function consumes the 'if' keyword, parses the parenthesized condition,
    /// and then parses the `then` branch statement. It then checks for an optional
    /// 'else' keyword and parses the `else` branch statement if present.
    fn if_statment(&mut self) -> Result<Stmt, ParseError> {
        // step over the if
        self.advance();

        self.consume(TokenType::LeftParen, "Expect '(' after if.")?;

        let condition = self.expression()?;

        self.consume(TokenType::RightParen, "Expect ')' after if.")?;

        let then_branch = Box::new(self.statement()?);
        let else_branch = if self.check(&TokenType::Else) {
            self.advance();
            Some(Box::new(self.statement()?))
        } else {
            None
        };

        Ok(Stmt::If(IfStmt {
            condition,
            then_branch,
            else_branch,
        }))
    }

    /// This function checks which kind of Statement a token is and returns it or throws a parsing
    /// error
    fn statement(&mut self) -> Result<Stmt, ParseError> {
        match self.peek().token_type() {
            TokenType::Print => self.print_statement(),
            TokenType::LeftBrace => self.block_statement(),
            TokenType::If => self.if_statment(),
            TokenType::While => self.while_statment(),
            TokenType::For => self.for_statement(),
            TokenType::Return => self.return_statement(),
            TokenType::Break => self.break_statement(),
            TokenType::Continue => self.continue_statement(),
            _ => self.expression_statement(),
        }
    }

    fn break_statement(&mut self) -> Result<Stmt, ParseError> {
        self.advance();
        self.consume(TokenType::Semicolon, "Expect ';' after break.")?;
        Ok(Stmt::Break)
    }

    fn continue_statement(&mut self) -> Result<Stmt, ParseError> {
        self.advance();
        self.consume(TokenType::Semicolon, "Expect ';' after continue.")?;
        Ok(Stmt::Continue)
    }

    fn return_statement(&mut self) -> Result<Stmt, ParseError> {
        self.advance();

        let mut value: Option<Box<Expr>> = None;
        if !self.check(&TokenType::Semicolon) {
            value = Some(Box::new(self.expression()?));
        }

        self.consume(TokenType::Semicolon, "Expect ';' after return value.")?;

        Ok(Stmt::Return(ReturnStmt {
            keyword: self.previous().clone(),
            value,
        }))
    }

    /// Parses a declaration, which can be a variable declaration or any other statement.
    ///
    /// This function peeks at the current token to determine if it's a `var` keyword.
    /// If it is, it calls `variable_declaration` to parse a variable declaration.
    /// Otherwise, it calls `statement` to parse any other type of statement.
    ///
    /// After attempting to parse a declaration, it includes error handling to synchronize
    /// the parser's state in case of an error.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing the parsed `Stmt` if successful.
    /// If a `ParseError` occurs during parsing, the parser's state is synchronized,
    /// and the error is returned.
    fn declaration(&mut self) -> Result<Stmt, ParseError> {
        match self.peek().token_type() {
            TokenType::VarKeyword => self.variable_declaration(),
            TokenType::Class => self.class_declaration(),
            TokenType::Fn => self.function("function"),
            _ => self.statement(),
        }
        .inspect_err(|_| {
            self.synchronize();
        })
    }

    fn class_declaration(&mut self) -> Result<Stmt, ParseError> {
        self.advance();
        let name = self.consume(TokenType::Var, "Expect class name.")?.clone();

        self.consume(TokenType::LeftBrace, "Expect '{' before class body.")?;

        let mut methods: Vec<FunctionStmt> = Vec::new();
        while !self.check(&TokenType::RightBrace) && !self.is_at_end() {
            if let Stmt::Function(method) = self.function("method")? {
                methods.push(method);
            } else {
                return Err(error(
                    self.peek(),
                    format!(
                        "Unexpected character in class declaration '{}'.",
                        self.peek().lexeme()
                    ),
                ));
            }
        }

        self.consume(TokenType::RightBrace, "Expect '}' after class body.")?;

        Ok(Stmt::Class(ClassStmt { name, methods }))
    }

    fn function(&mut self, kind: &str) -> Result<Stmt, ParseError> {
        self.advance();
        let name = self
            .consume(TokenType::Var, &format!("Expect {kind} name."))?
            .clone();

        self.consume(
            TokenType::LeftParen,
            &format!("Expect '(' after {kind} name."),
        )?;

        let mut params: Vec<Token> = Vec::new();

        if !self.check(&TokenType::RightParen) {
            params.push(
                self.consume(TokenType::Var, "Expect parameter name.")?
                    .clone(),
            );
            while self.match_token(TokenType::Comma) {
                if params.len() >= 255 {
                    error(self.peek(), "Can't have more than 255 arguments.".into());
                }

                params.push(
                    self.consume(TokenType::Var, "Expect parameter name.")?
                        .clone(),
                );
            }
        }

        self.consume(TokenType::RightParen, "Expect ')' after parameters.")?;

        // we cant consume the token here because block_statement() consumes the opening brace in
        // the bginning
        if !self.check(&TokenType::LeftBrace) {
            return Err(error(
                self.peek(),
                format!("Expect '{{' before {kind} body."),
            ));
        }

        let body = self.block_statement()?;

        let body_stmts = match body {
            Stmt::Block(stmts) => stmts,
            _ => {
                return Err(error(
                    &name,
                    "Expected block statement as function body".to_string(),
                ))
            }
        };

        Ok(Stmt::Function(FunctionStmt {
            name,
            params,
            body: body_stmts,
        }))
    }

    /// Parses a `for` statement.
    ///
    /// The structure of a `for` loop is:
    /// `for (initializer; condition; increment) { body }`
    ///
    /// The initializer, condition, and increment are all optional.
    ///
    /// This function consumes the 'for' keyword, parses the parenthesized clauses,
    /// and then parses the loop body. It then transforms the `for` loop
    /// into a `while` loop with an optional initializer and increment.
    fn for_statement(&mut self) -> Result<Stmt, ParseError> {
        self.advance(); // Consume 'for'

        self.consume(TokenType::LeftParen, "Expect '(' after 'for'.")?;

        let initializer = if self.match_token(TokenType::Semicolon) {
            None
        } else if self.check(&TokenType::VarKeyword) {
            Some(self.variable_declaration()?)
        } else {
            Some(self.expression_statement()?)
        };

        let condition = if !self.check(&TokenType::Semicolon) {
            Some(self.expression()?)
        } else {
            None
        };
        self.consume(TokenType::Semicolon, "Expect ';' after loop condition.")?;

        let increment = if !self.check(&TokenType::RightParen) {
            Some(self.expression()?)
        } else {
            None
        };
        self.consume(TokenType::RightParen, "Expect ')' after for clauses.")?;

        let mut body = self.statement()?;

        if let Some(inc) = increment {
            body = Stmt::Block(vec![body, Stmt::Expression(inc)]);
        }

        body = Stmt::While(WhileStmt {
            condition: condition.unwrap_or(Expr::Literal(LiteralExpr {
                literal: Token::new(
                    TokenType::True,
                    "true",
                    Some(Object::Boolean(true)),
                    self.peek().line(),
                    self.peek().token_number(),
                ),
            })),
            body: Box::new(body),
        });

        if let Some(init) = initializer {
            body = Stmt::Block(vec![init, body]);
        }

        Ok(body)
    }

    /// Parses a `while` statement.
    ///
    /// The structure of a `while` loop is:
    /// `while (condition) { body }`
    ///
    /// This function consumes the 'while' keyword, parses the parenthesized condition,
    /// and then parses the loop body.
    ///
    fn while_statment(&mut self) -> Result<Stmt, ParseError> {
        // step over the while
        self.advance();

        self.consume(TokenType::LeftParen, "Expect '(' after while.")?;

        let condition = self.expression()?;

        self.consume(TokenType::RightParen, "Expect ')' after while.")?;

        let body = Box::new(self.statement()?);

        Ok(Stmt::While(WhileStmt { condition, body }))
    }

    fn variable_declaration(&mut self) -> Result<Stmt, ParseError> {
        self.advance();
        let name: Token = if self.match_token(TokenType::Var) {
            self.previous().clone()
        } else {
            return Err(error(
                self.peek(),
                "Token is not a variable identifier".to_string(),
            ));
        };

        let initializer: Option<Expr> = if self.match_token(TokenType::Equal) {
            Some(self.expression()?)
        } else {
            None
        };

        if !self.match_token(TokenType::Semicolon) {
            return Err(error(
                self.peek(),
                "Expect ';' after expression.".to_string(),
            ));
        } else {
            Ok(Stmt::Var(VarStmt { name, initializer }))
        }
    }

    /// Returns a 'Stmt::Print' statement after evaluating the expression signaling to the
    /// StmtVisitor to print the result
    fn print_statement(&mut self) -> Result<Stmt, ParseError> {
        // advance to skip print
        self.advance();

        let val: Expr = self.expression()?;

        self.consume(TokenType::Semicolon, "Expect ';' after expression.")?;

        Ok(Stmt::Print(val))
    }

    /// Generates a block statement and generates a 'Stmt::Block' which evaluates to a list of
    /// other statments
    fn block_statement(&mut self) -> Result<Stmt, ParseError> {
        // advance past the opening brace
        self.advance();

        let mut statements = Vec::new();

        while !self.check(&TokenType::RightBrace) && !self.is_at_end() {
            statements.push(self.declaration()?);
        }

        self.consume(TokenType::RightBrace, "Expect '}' after block.")?;
        Ok(Stmt::Block(statements))
    }

    /// Evaluates the expression and returns it as a 'Stmt::Expression'
    fn expression_statement(&mut self) -> Result<Stmt, ParseError> {
        let val: Expr = self.expression()?;

        self.consume(TokenType::Semicolon, "Expect ';' after expression.")?;

        Ok(Stmt::Expression(val))
    }

    /// Parses a function call expression.
    ///
    /// This function handles the parsing of a primary expression followed by zero or more
    /// function calls. It iteratively checks for left parentheses `(` to identify call
    /// expressions and delegates the parsing of the arguments to the `finish_call`
    /// function.
    fn call(&mut self) -> Result<Expr, ParseError> {
        let mut expr = self.primary()?;

        loop {
            if self.match_token(TokenType::LeftParen) {
                expr = self.finish_call(expr)?;
            } else if self.match_token(TokenType::Dot) {
                let name = self
                    .consume(TokenType::Var, "Expect property name after '.'.")?
                    .clone();

                expr = Expr::PropertyAccess(PropertyAccessExpr {
                    object: Box::new(expr),
                    name,
                });
            } else {
                break;
            }
        }

        Ok(expr)
    }

    /// Finishes parsing a function call expression.
    ///
    /// This function is called after the opening parenthesis `(` of a function call
    /// has been matched. It parses the arguments of the call, which are
    /// comma-separated expressions, and consumes the closing parenthesis `)`.
    ///
    /// We check for that case first by seeing if the next token is ). If it is, we don’t try to parse any arguments
    ///
    /// # Arguments
    ///
    /// * `callee`: The expression that is being called.
    ///
    fn finish_call(&mut self, callee: Expr) -> Result<Expr, ParseError> {
        let mut arguments: Vec<Expr> = Vec::new();

        if !self.check(&TokenType::RightParen) {
            arguments.push(self.expression()?);
            while self.match_token(TokenType::Comma) {
                // technically we could make this as long as possible but most language specs dont
                // and its gonna make it easier to implement a bytcode VM or make a compiler out
                // of this...
                if arguments.len() >= 255 {
                    error(self.peek(), "Can't have more than 255 arguments.".into());
                }

                arguments.push(self.expression()?);
            }
        }

        Ok(Expr::Call(CallExpr {
            callee: Box::new(callee),
            paren: self
                .consume(TokenType::RightParen, "Expect ')' after arguments.")?
                .clone(),
            arguments,
        }))
    }
}

/// Parses a list of tokens into an abstract syntax tree (AST).
///
/// This parses a series of statements, as many as it can find until it hits the end of the input
///
/// This is a convenience function that creates a `Parser` instance and
/// calls its `parse` method.
///
/// # Arguments
///
/// * `token_input` - A `Vec<Token>` representing the input tokens.
///
/// # Returns
///
/// A `Result` containing a `Vec<Stmt>` representing the roots of the AST on
/// successful parsing without errors, or a `String` containing an error message
/// if parsing failed or completed with errors.
pub fn parse(token_input: Vec<Token>) -> Result<Vec<Stmt>, Vec<ParseError>> {
    let mut stmts: Vec<Stmt> = Vec::new();
    let mut parser = Parser::new(token_input);
    let mut parser_errors: Vec<ParseError> = Vec::new();

    while !parser.is_at_end() {
        match parser.declaration() {
            Ok(statement) => stmts.push(statement),
            Err(error) => {
                parser.had_error = true;
                parser_errors.push(error);
            }
        }
    }

    if parser.had_error {
        Err(parser_errors)
    } else {
        Ok(stmts)
    }
}

#[cfg(test)]
mod tests {
    use crate::expr_types::*;
    use crate::object::Object;
    use crate::parser;
    use crate::stmt_types::*;
    use crate::token::{Token, TokenType};

    // Helper function to create tokens for testing
    fn token(token_type: TokenType, lexeme: &str, literal: Option<Object>, line: usize) -> Token {
        Token::new(token_type, lexeme, literal, line, 0)
    }

    #[test]
    fn test_parse_expression_literal() {
        let tokens = vec![
            token(TokenType::Number, "42", Some(Object::Number(42.0)), 1),
            token(TokenType::Semicolon, ";", None, 1),
            token(TokenType::Eof, "", None, 1),
        ];

        let result = parser::parse(tokens);
        assert!(result.is_ok());

        let statements = result.unwrap();
        assert_eq!(statements.len(), 1);

        match &statements[0] {
            Stmt::Expression(expr) => match expr {
                Expr::Literal(lit_expr) => {
                    if let Some(Object::Number(value)) = lit_expr.literal.literal() {
                        assert_eq!(*value, 42.0);
                    } else {
                        panic!("Expected number literal");
                    }
                }
                _ => panic!("Expected literal expression"),
            },
            _ => panic!("Expected expression statement"),
        }
    }

    #[test]
    fn test_parse_variable_declaration() {
        let tokens = vec![
            token(TokenType::VarKeyword, "var", None, 1),
            token(TokenType::Var, "x", None, 1),
            token(TokenType::Equal, "=", None, 1),
            token(TokenType::Number, "10", Some(Object::Number(10.0)), 1),
            token(TokenType::Semicolon, ";", None, 1),
            token(TokenType::Eof, "", None, 1),
        ];

        let result = parser::parse(tokens);
        assert!(result.is_ok());

        let statements = result.unwrap();
        assert_eq!(statements.len(), 1);

        match &statements[0] {
            Stmt::Var(var_stmt) => {
                assert_eq!(var_stmt.name.lexeme(), "x");

                match &var_stmt.initializer {
                    Some(Expr::Literal(lit_expr)) => {
                        if let Some(Object::Number(value)) = lit_expr.literal.literal() {
                            assert_eq!(*value, 10.0);
                        } else {
                            panic!("Expected number literal");
                        }
                    }
                    _ => panic!("Expected literal expression as initializer"),
                }
            }
            _ => panic!("Expected variable declaration statement"),
        }
    }

    #[test]
    fn test_parse_assignment() {
        let tokens = vec![
            token(TokenType::Var, "x", None, 1),
            token(TokenType::Equal, "=", None, 1),
            token(TokenType::Number, "42", Some(Object::Number(42.0)), 1),
            token(TokenType::Semicolon, ";", None, 1),
            token(TokenType::Eof, "", None, 1),
        ];

        let result = parser::parse(tokens);
        assert!(result.is_ok());

        let statements = result.unwrap();
        assert_eq!(statements.len(), 1);

        match &statements[0] {
            Stmt::Expression(expr) => match expr {
                Expr::Assign(assign_expr) => {
                    assert_eq!(assign_expr.name.lexeme(), "x");

                    match &*assign_expr.value {
                        Expr::Literal(lit_expr) => {
                            if let Some(Object::Number(value)) = lit_expr.literal.literal() {
                                assert_eq!(*value, 42.0);
                            } else {
                                panic!("Expected number literal");
                            }
                        }
                        _ => panic!("Expected literal expression as assignment value"),
                    }
                }
                _ => panic!("Expected assignment expression"),
            },
            _ => panic!("Expected expression statement"),
        }
    }

    #[test]
    fn test_parse_binary_expression() {
        let tokens = vec![
            token(TokenType::Number, "1", Some(Object::Number(1.0)), 1),
            token(TokenType::Plus, "+", None, 1),
            token(TokenType::Number, "2", Some(Object::Number(2.0)), 1),
            token(TokenType::Semicolon, ";", None, 1),
            token(TokenType::Eof, "", None, 1),
        ];

        let result = parser::parse(tokens);
        assert!(result.is_ok());

        let statements = result.unwrap();
        assert_eq!(statements.len(), 1);

        match &statements[0] {
            Stmt::Expression(expr) => match expr {
                Expr::Binary(bin_expr) => {
                    match &*bin_expr.left {
                        Expr::Literal(lit_expr) => {
                            if let Some(Object::Number(value)) = lit_expr.literal.literal() {
                                assert_eq!(*value, 1.0);
                            } else {
                                panic!("Expected number literal");
                            }
                        }
                        _ => panic!("Expected literal expression as left operand"),
                    }

                    assert_eq!(bin_expr.operator.token_type(), &TokenType::Plus);

                    match &*bin_expr.right {
                        Expr::Literal(lit_expr) => {
                            if let Some(Object::Number(value)) = lit_expr.literal.literal() {
                                assert_eq!(*value, 2.0);
                            } else {
                                panic!("Expected number literal");
                            }
                        }
                        _ => panic!("Expected literal expression as right operand"),
                    }
                }
                _ => panic!("Expected binary expression"),
            },
            _ => panic!("Expected expression statement"),
        }
    }

    #[test]
    fn test_parse_grouping_expression() {
        let tokens = vec![
            token(TokenType::LeftParen, "(", None, 1),
            token(TokenType::Number, "42", Some(Object::Number(42.0)), 1),
            token(TokenType::RightParen, ")", None, 1),
            token(TokenType::Semicolon, ";", None, 1),
            token(TokenType::Eof, "", None, 1),
        ];

        let result = parser::parse(tokens);
        assert!(result.is_ok());

        let statements = result.unwrap();
        assert_eq!(statements.len(), 1);

        match &statements[0] {
            Stmt::Expression(expr) => match expr {
                Expr::Grouping(group_expr) => match &*group_expr.expr {
                    Expr::Literal(lit_expr) => {
                        if let Some(Object::Number(value)) = lit_expr.literal.literal() {
                            assert_eq!(*value, 42.0);
                        } else {
                            panic!("Expected number literal");
                        }
                    }
                    _ => panic!("Expected literal expression in grouping"),
                },
                _ => panic!("Expected grouping expression"),
            },
            _ => panic!("Expected expression statement"),
        }
    }

    #[test]
    fn test_parse_unary_expression() {
        let tokens = vec![
            token(TokenType::Minus, "-", None, 1),
            token(TokenType::Number, "42", Some(Object::Number(42.0)), 1),
            token(TokenType::Semicolon, ";", None, 1),
            token(TokenType::Eof, "", None, 1),
        ];

        let result = parser::parse(tokens);
        assert!(result.is_ok());

        let statements = result.unwrap();
        assert_eq!(statements.len(), 1);

        match &statements[0] {
            Stmt::Expression(expr) => match expr {
                Expr::Unary(unary_expr) => {
                    assert_eq!(unary_expr.prefix.token_type(), &TokenType::Minus);

                    match &*unary_expr.operator {
                        Expr::Literal(lit_expr) => {
                            if let Some(Object::Number(value)) = lit_expr.literal.literal() {
                                assert_eq!(*value, 42.0);
                            } else {
                                panic!("Expected number literal");
                            }
                        }
                        _ => panic!("Expected literal expression as unary operand"),
                    }
                }
                _ => panic!("Expected unary expression"),
            },
            _ => panic!("Expected expression statement"),
        }
    }

    #[test]
    fn test_parse_logical_expression() {
        let tokens = vec![
            token(TokenType::True, "true", Some(Object::Boolean(true)), 1),
            token(TokenType::And, "and", None, 1),
            token(TokenType::False, "false", Some(Object::Boolean(false)), 1),
            token(TokenType::Semicolon, ";", None, 1),
            token(TokenType::Eof, "", None, 1),
        ];

        let result = parser::parse(tokens);
        assert!(result.is_ok());

        let statements = result.unwrap();
        assert_eq!(statements.len(), 1);

        match &statements[0] {
            Stmt::Expression(expr) => match expr {
                Expr::Logical(logical_expr) => {
                    match &*logical_expr.left {
                        Expr::Literal(lit_expr) => {
                            if let Some(Object::Boolean(value)) = lit_expr.literal.literal() {
                                assert!(*value);
                            } else {
                                panic!("Expected boolean literal");
                            }
                        }
                        _ => panic!("Expected literal expression as left operand"),
                    }

                    assert_eq!(logical_expr.operator.token_type(), &TokenType::And);

                    match &*logical_expr.right {
                        Expr::Literal(lit_expr) => {
                            if let Some(Object::Boolean(value)) = lit_expr.literal.literal() {
                                assert!(!*value);
                            } else {
                                panic!("Expected boolean literal");
                            }
                        }
                        _ => panic!("Expected literal expression as right operand"),
                    }
                }
                _ => panic!("Expected logical expression"),
            },
            _ => panic!("Expected expression statement"),
        }
    }

    #[test]
    fn test_parse_print_statement() {
        let tokens = vec![
            token(TokenType::Print, "print", None, 1),
            token(
                TokenType::String,
                "\"Hello, World!\"",
                Some(Object::String("Hello, World!".to_string())),
                1,
            ),
            token(TokenType::Semicolon, ";", None, 1),
            token(TokenType::Eof, "", None, 1),
        ];

        let result = parser::parse(tokens);
        assert!(result.is_ok());

        let statements = result.unwrap();
        assert_eq!(statements.len(), 1);

        match &statements[0] {
            Stmt::Print(expr) => match expr {
                Expr::Literal(lit_expr) => {
                    if let Some(Object::String(value)) = lit_expr.literal.literal() {
                        assert_eq!(value, "Hello, World!");
                    } else {
                        panic!("Expected string literal");
                    }
                }
                _ => panic!("Expected literal expression"),
            },
            _ => panic!("Expected print statement"),
        }
    }

    #[test]
    fn test_parse_block_statement() {
        let tokens = vec![
            token(TokenType::LeftBrace, "{", None, 1),
            token(TokenType::VarKeyword, "var", None, 1),
            token(TokenType::Var, "x", None, 1),
            token(TokenType::Equal, "=", None, 1),
            token(TokenType::Number, "10", Some(Object::Number(10.0)), 1),
            token(TokenType::Semicolon, ";", None, 1),
            token(TokenType::Print, "print", None, 2),
            token(TokenType::Var, "x", None, 2),
            token(TokenType::Semicolon, ";", None, 2),
            token(TokenType::RightBrace, "}", None, 3),
            token(TokenType::Eof, "", None, 3),
        ];

        let result = parser::parse(tokens);
        assert!(result.is_ok());

        let statements = result.unwrap();
        assert_eq!(statements.len(), 1);

        match &statements[0] {
            Stmt::Block(block_stmts) => {
                assert_eq!(block_stmts.len(), 2);

                // First statement should be variable declaration
                match &block_stmts[0] {
                    Stmt::Var(var_stmt) => {
                        assert_eq!(var_stmt.name.lexeme(), "x");
                    }
                    _ => panic!("Expected variable declaration statement"),
                }

                // Second statement should be print statement
                match &block_stmts[1] {
                    Stmt::Print(expr) => match expr {
                        Expr::Variable(var_expr) => {
                            assert_eq!(var_expr.name.lexeme(), "x");
                        }
                        _ => panic!("Expected variable expression"),
                    },
                    _ => panic!("Expected print statement"),
                }
            }
            _ => panic!("Expected block statement"),
        }
    }

    #[test]
    fn test_parse_if_statement() {
        let tokens = vec![
            token(TokenType::If, "if", None, 1),
            token(TokenType::LeftParen, "(", None, 1),
            token(TokenType::True, "true", Some(Object::Boolean(true)), 1),
            token(TokenType::RightParen, ")", None, 1),
            token(TokenType::LeftBrace, "{", None, 1),
            token(TokenType::Print, "print", None, 2),
            token(
                TokenType::String,
                "\"Then branch\"",
                Some(Object::String("Then branch".to_string())),
                2,
            ),
            token(TokenType::Semicolon, ";", None, 2),
            token(TokenType::RightBrace, "}", None, 3),
            token(TokenType::Else, "else", None, 3),
            token(TokenType::LeftBrace, "{", None, 3),
            token(TokenType::Print, "print", None, 4),
            token(
                TokenType::String,
                "\"Else branch\"",
                Some(Object::String("Else branch".to_string())),
                4,
            ),
            token(TokenType::Semicolon, ";", None, 4),
            token(TokenType::RightBrace, "}", None, 5),
            token(TokenType::Eof, "", None, 5),
        ];

        let result = parser::parse(tokens);
        assert!(result.is_ok());

        let statements = result.unwrap();
        assert_eq!(statements.len(), 1);

        match &statements[0] {
            Stmt::If(if_stmt) => {
                // Check condition
                match &if_stmt.condition {
                    Expr::Literal(lit_expr) => {
                        if let Some(Object::Boolean(value)) = lit_expr.literal.literal() {
                            assert!(*value);
                        } else {
                            panic!("Expected boolean literal");
                        }
                    }
                    _ => panic!("Expected literal expression as condition"),
                }

                // Check then branch
                match &*if_stmt.then_branch {
                    Stmt::Block(then_stmts) => {
                        assert_eq!(then_stmts.len(), 1);
                        match &then_stmts[0] {
                            Stmt::Print(expr) => match expr {
                                Expr::Literal(lit_expr) => {
                                    if let Some(Object::String(value)) = lit_expr.literal.literal()
                                    {
                                        assert_eq!(value, "Then branch");
                                    } else {
                                        panic!("Expected string literal");
                                    }
                                }
                                _ => panic!("Expected literal expression"),
                            },
                            _ => panic!("Expected print statement"),
                        }
                    }
                    _ => panic!("Expected block statement as then branch"),
                }

                // Check else branch
                match &if_stmt.else_branch {
                    Some(else_branch) => match &**else_branch {
                        Stmt::Block(else_stmts) => {
                            assert_eq!(else_stmts.len(), 1);
                            match &else_stmts[0] {
                                Stmt::Print(expr) => match expr {
                                    Expr::Literal(lit_expr) => {
                                        if let Some(Object::String(value)) =
                                            lit_expr.literal.literal()
                                        {
                                            assert_eq!(value, "Else branch");
                                        } else {
                                            panic!("Expected string literal");
                                        }
                                    }
                                    _ => panic!("Expected literal expression"),
                                },
                                _ => panic!("Expected print statement"),
                            }
                        }
                        _ => panic!("Expected block statement as else branch"),
                    },
                    None => panic!("Expected else branch"),
                }
            }
            _ => panic!("Expected if statement"),
        }
    }

    #[test]
    fn test_parse_while_statement() {
        let tokens = vec![
            token(TokenType::While, "while", None, 1),
            token(TokenType::LeftParen, "(", None, 1),
            token(TokenType::True, "true", Some(Object::Boolean(true)), 1),
            token(TokenType::RightParen, ")", None, 1),
            token(TokenType::LeftBrace, "{", None, 1),
            token(TokenType::Print, "print", None, 2),
            token(
                TokenType::String,
                "\"Loop body\"",
                Some(Object::String("Loop body".to_string())),
                2,
            ),
            token(TokenType::Semicolon, ";", None, 2),
            token(TokenType::RightBrace, "}", None, 3),
            token(TokenType::Eof, "", None, 3),
        ];

        let result = parser::parse(tokens);
        assert!(result.is_ok());

        let statements = result.unwrap();
        assert_eq!(statements.len(), 1);

        match &statements[0] {
            Stmt::While(while_stmt) => {
                // Check condition
                match &while_stmt.condition {
                    Expr::Literal(lit_expr) => {
                        if let Some(Object::Boolean(value)) = lit_expr.literal.literal() {
                            assert!(*value);
                        } else {
                            panic!("Expected boolean literal");
                        }
                    }
                    _ => panic!("Expected literal expression as condition"),
                }

                // Check body
                match &*while_stmt.body {
                    Stmt::Block(body_stmts) => {
                        assert_eq!(body_stmts.len(), 1);
                        match &body_stmts[0] {
                            Stmt::Print(expr) => match expr {
                                Expr::Literal(lit_expr) => {
                                    if let Some(Object::String(value)) = lit_expr.literal.literal()
                                    {
                                        assert_eq!(value, "Loop body");
                                    } else {
                                        panic!("Expected string literal");
                                    }
                                }
                                _ => panic!("Expected literal expression"),
                            },
                            _ => panic!("Expected print statement"),
                        }
                    }
                    _ => panic!("Expected block statement as while body"),
                }
            }
            _ => panic!("Expected while statement"),
        }
    }

    #[test]
    fn test_parse_for_statement() {
        let tokens = vec![
            token(TokenType::For, "for", None, 1),
            token(TokenType::LeftParen, "(", None, 1),
            token(TokenType::VarKeyword, "var", None, 1),
            token(TokenType::Var, "i", None, 1),
            token(TokenType::Equal, "=", None, 1),
            token(TokenType::Number, "0", Some(Object::Number(0.0)), 1),
            token(TokenType::Semicolon, ";", None, 1),
            token(TokenType::Var, "i", None, 1),
            token(TokenType::Less, "<", None, 1),
            token(TokenType::Number, "10", Some(Object::Number(10.0)), 1),
            token(TokenType::Semicolon, ";", None, 1),
            token(TokenType::Var, "i", None, 1),
            token(TokenType::Equal, "=", None, 1),
            token(TokenType::Var, "i", None, 1),
            token(TokenType::Plus, "+", None, 1),
            token(TokenType::Number, "1", Some(Object::Number(1.0)), 1),
            token(TokenType::RightParen, ")", None, 1),
            token(TokenType::LeftBrace, "{", None, 1),
            token(TokenType::Print, "print", None, 2),
            token(TokenType::Var, "i", None, 2),
            token(TokenType::Semicolon, ";", None, 2),
            token(TokenType::RightBrace, "}", None, 3),
            token(TokenType::Eof, "", None, 3),
        ];

        let result = parser::parse(tokens);
        assert!(result.is_ok());

        let statements = result.unwrap();
        assert_eq!(statements.len(), 1);

        // For loops are desugared into while loops with blocks
        match &statements[0] {
            Stmt::Block(block_stmts) => {
                assert_eq!(block_stmts.len(), 2);

                // First statement should be variable declaration for initializer
                match &block_stmts[0] {
                    Stmt::Var(var_stmt) => {
                        assert_eq!(var_stmt.name.lexeme(), "i");
                    }
                    _ => panic!("Expected variable declaration statement for initializer"),
                }

                // Second statement should be while loop
                match &block_stmts[1] {
                    Stmt::While(while_stmt) => {
                        // Check condition
                        match &while_stmt.condition {
                            Expr::Binary(bin_expr) => {
                                match &*bin_expr.left {
                                    Expr::Variable(var_expr) => {
                                        assert_eq!(var_expr.name.lexeme(), "i");
                                    }
                                    _ => panic!("Expected variable expression as left operand"),
                                }

                                assert_eq!(bin_expr.operator.token_type(), &TokenType::Less);

                                match &*bin_expr.right {
                                    Expr::Literal(lit_expr) => {
                                        if let Some(Object::Number(value)) =
                                            lit_expr.literal.literal()
                                        {
                                            assert_eq!(*value, 10.0);
                                        } else {
                                            panic!("Expected number literal");
                                        }
                                    }
                                    _ => panic!("Expected literal expression as right operand"),
                                }
                            }
                            _ => panic!("Expected binary expression as condition"),
                        }

                        // Check body (should be a block with the original body and increment)
                        match &*while_stmt.body {
                            Stmt::Block(body_stmts) => {
                                assert_eq!(body_stmts.len(), 2);

                                // First statement should be the original body
                                match &body_stmts[0] {
                                    Stmt::Block(original_body) => {
                                        assert_eq!(original_body.len(), 1);

                                        match &original_body[0] {
                                            Stmt::Print(expr) => match expr {
                                                Expr::Variable(var_expr) => {
                                                    assert_eq!(var_expr.name.lexeme(), "i");
                                                }
                                                _ => panic!("Expected variable expression"),
                                            },
                                            _ => panic!("Expected print statement"),
                                        }
                                    }
                                    _ => panic!("Expected block statement as original body"),
                                }

                                // Second statement should be the increment
                                match &body_stmts[1] {
                                    Stmt::Expression(expr) => {
                                        match expr {
                                            Expr::Assign(_) => {
                                                // This is the increment expression
                                                // We could check more details but this is sufficient
                                            }
                                            _ => panic!(
                                                "Expected assignment expression as increment"
                                            ),
                                        }
                                    }
                                    _ => panic!("Expected expression statement as increment"),
                                }
                            }
                            _ => panic!("Expected block statement as while body"),
                        }
                    }
                    _ => panic!("Expected while statement as desugared for loop"),
                }
            }
            _ => panic!("Expected block statement as desugared for loop"),
        }
    }

    #[test]
    fn test_parse_function_declaration() {
        let tokens = vec![
            token(TokenType::Fn, "fn", None, 1),
            token(TokenType::Var, "add", None, 1),
            token(TokenType::LeftParen, "(", None, 1),
            token(TokenType::Var, "a", None, 1),
            token(TokenType::Comma, ",", None, 1),
            token(TokenType::Var, "b", None, 1),
            token(TokenType::RightParen, ")", None, 1),
            token(TokenType::LeftBrace, "{", None, 1),
            token(TokenType::Return, "return", None, 2),
            token(TokenType::Var, "a", None, 2),
            token(TokenType::Plus, "+", None, 2),
            token(TokenType::Var, "b", None, 2),
            token(TokenType::Semicolon, ";", None, 2),
            token(TokenType::RightBrace, "}", None, 3),
            token(TokenType::Eof, "", None, 3),
        ];

        let result = parser::parse(tokens);
        assert!(result.is_ok());

        let statements = result.unwrap();
        assert_eq!(statements.len(), 1);

        match &statements[0] {
            Stmt::Function(func_stmt) => {
                // Check function name
                assert_eq!(func_stmt.name.lexeme(), "add");

                // Check parameters
                assert_eq!(func_stmt.params.len(), 2);
                assert_eq!(func_stmt.params[0].lexeme(), "a");
                assert_eq!(func_stmt.params[1].lexeme(), "b");

                // Check body
                assert_eq!(func_stmt.body.len(), 1);

                match &func_stmt.body[0] {
                    Stmt::Return(return_stmt) => match &return_stmt.value {
                        Some(expr) => match &**expr {
                            Expr::Binary(bin_expr) => {
                                match &*bin_expr.left {
                                    Expr::Variable(var_expr) => {
                                        assert_eq!(var_expr.name.lexeme(), "a");
                                    }
                                    _ => panic!("Expected variable expression as left operand"),
                                }

                                assert_eq!(bin_expr.operator.token_type(), &TokenType::Plus);

                                match &*bin_expr.right {
                                    Expr::Variable(var_expr) => {
                                        assert_eq!(var_expr.name.lexeme(), "b");
                                    }
                                    _ => panic!("Expected variable expression as right operand"),
                                }
                            }
                            _ => panic!("Expected binary expression as return value"),
                        },
                        None => panic!("Expected return value"),
                    },
                    _ => panic!("Expected return statement in function body"),
                }
            }
            _ => panic!("Expected function declaration"),
        }
    }
}
