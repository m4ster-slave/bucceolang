use crate::expr_types::*;
use crate::object::Object;
use crate::parser_error::{self, error, ParseError};
use crate::stmt_types::{IfStmt, Stmt, VarStmt, WhileStmt};
use crate::token::TokenType;
use crate::Token;

/// A recursive descent parser that takes a list of tokens and generates an abstract syntax tree (AST).
///
/// The parser follows the grammar of the language to construct an AST representation
/// of the input code. It handles operator precedence and associativity through
/// a series of parsing methods.
pub struct Parser {
    /// The list of tokens generated by the scanner.
    tokens: Vec<Token>,
    /// The index of the current token being considered.
    current: usize,
    /// A flag indicating whether a parsing error has occurred.
    had_error: bool,
}

impl Parser {
    /// Creates a new `Parser` with the given list of tokens.
    ///
    /// # Arguments
    ///
    /// * `tokens` - A `Vec<Token>` representing the input tokens.
    pub fn new(tokens: Vec<Token>) -> Self {
        Parser {
            tokens,
            current: 0,
            had_error: false,
        }
    }

    /// Parses an expression according to the language's grammar.
    ///
    /// This method is the entry point for parsing expressions. It delegates
    /// to the `equality` method, which handles the lowest precedence operator.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` on success, or a `ParseError` if a
    /// parsing error occurs during the expression parsing.
    fn expression(&mut self) -> Result<Expr, ParseError> {
        self.assignment()
    }

    fn or(&mut self) -> Result<Expr, ParseError> {
        let mut expr = self.and()?;

        while self.match_token(TokenType::Or) {
            let operator = self.previous().clone();
            let right = self.and()?;

            expr = Expr::Logical(LogicalExpr {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            });
        }

        Ok(expr)
    }

    fn and(&mut self) -> Result<Expr, ParseError> {
        let mut expr = self.equality()?;

        while self.match_token(TokenType::And) {
            let operator = self.previous().clone();
            let right = self.equality()?;

            expr = Expr::Logical(LogicalExpr {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            });
        }

        Ok(expr)
    }

    fn assignment(&mut self) -> Result<Expr, ParseError> {
        let expr = self.or()?;

        if self.match_token(TokenType::Equal) {
            let equals = self.previous().clone();
            let value = self.assignment()?;

            match expr {
                Expr::Variable(var_expr) => {
                    return Ok(Expr::Assign(AssignExpr {
                        name: var_expr.name,
                        value: Box::new(value),
                    }))
                }
                _ => return Err(error(&equals, "Invalid assignment target.".to_string())),
            }
        }

        Ok(expr)
    }

    /// Parses an equality expression (`==`, `!=`).
    ///
    /// This method parses a comparison expression and then checks for
    /// equality or inequality operators, building binary expression nodes
    /// as needed.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` representing the parsed equality
    /// expression, or a `ParseError` if an error occurs.
    fn equality(&mut self) -> Result<Expr, ParseError> {
        let mut expr = self.comparison()?;
        while self.match_tokens(&[TokenType::BangEqual, TokenType::EqualEqual]) {
            let operator = self.previous().clone();
            let right = self.comparison().inspect_err(|_| {
                self.had_error = true;
                self.synchronize();
            })?;
            expr = Expr::Binary(BinaryExpr {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            });
        }
        Ok(expr)
    }

    /// Parses a comparison expression (`>`, `>=`, `<`, `<=`).
    ///
    /// This method parses a term and then checks for comparison operators,
    /// building binary expression nodes as needed.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` representing the parsed comparison
    /// expression, or a `ParseError` if an error occurs.
    fn comparison(&mut self) -> Result<Expr, ParseError> {
        let mut expr = self.term()?;
        while self.match_tokens(&[
            TokenType::Greater,
            TokenType::GreaterEqual,
            TokenType::Less,
            TokenType::LessEqual,
        ]) {
            let operator = self.previous().clone();
            let right = self.term().inspect_err(|_| {
                self.had_error = true;
                self.synchronize();
            })?;
            expr = Expr::Binary(BinaryExpr {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            });
        }
        Ok(expr)
    }

    /// Parses an additive expression (`+`, `-`).
    ///
    /// This method parses a factor and then checks for additive operators,
    /// building binary expression nodes as needed.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` representing the parsed additive
    /// expression, or a `ParseError` if an error occurs.
    fn term(&mut self) -> Result<Expr, ParseError> {
        let mut expr = self.factor()?;
        while self.match_tokens(&[TokenType::Minus, TokenType::Plus]) {
            let operator = self.previous().clone();
            let right = self.factor().inspect_err(|_| {
                self.had_error = true;
                self.synchronize();
            })?;
            expr = Expr::Binary(BinaryExpr {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            });
        }
        Ok(expr)
    }

    /// Parses a multiplicative expression (`*`, `/`).
    ///
    /// This method parses a unary expression and then checks for multiplicative
    /// operators, building binary expression nodes as needed.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` representing the parsed multiplicative
    /// expression, or a `ParseError` if an error occurs.
    fn factor(&mut self) -> Result<Expr, ParseError> {
        let mut expr = self.unary()?;
        while self.match_tokens(&[TokenType::Slash, TokenType::Asterisk]) {
            let operator = self.previous().clone();
            let right = self.unary().inspect_err(|_| {
                self.had_error = true;
                self.synchronize();
            })?;
            expr = Expr::Binary(BinaryExpr {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            });
        }
        Ok(expr)
    }

    /// Parses a unary expression (`!`, `-`).
    ///
    /// This method checks for unary operators (`!` or `-`) and, if found,
    /// recursively parses the operand. Otherwise, it delegates to `primary`.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` representing the parsed unary
    /// expression or the result of `primary`, or a `ParseError` if an
    /// error occurs.
    fn unary(&mut self) -> Result<Expr, ParseError> {
        if self.match_tokens(&[TokenType::Bang, TokenType::Minus]) {
            let prefix = self.previous().clone();
            let operator = self.unary().inspect_err(|_| {
                self.had_error = true;
                self.synchronize();
            })?;
            return Ok(Expr::Unary(UnaryExpr {
                prefix,
                operator: Box::new(operator),
            }));
        }
        self.primary()
    }

    /// Parses the highest precedence expressions: literals, grouping, and variables.
    ///
    /// This method handles boolean literals (`true`, `false`, `nil`), number
    /// and string literals, parenthesized expressions, and variable references.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` representing the parsed primary
    /// expression, or a `ParseError` if an error occurs (e.g., unexpected token).
    fn primary(&mut self) -> Result<Expr, ParseError> {
        if self.match_tokens(&[TokenType::False, TokenType::True, TokenType::Nil]) {
            return Ok(Expr::Literal(LiteralExpr {
                literal: self.previous().clone(),
            }));
        }
        if let TokenType::Number = &self.peek().token_type() {
            self.advance();
            return Ok(Expr::Literal(LiteralExpr {
                literal: self.previous().clone(),
            }));
        }
        if let TokenType::String = &self.peek().token_type() {
            self.advance();
            return Ok(Expr::Literal(LiteralExpr {
                literal: self.previous().clone(),
            }));
        }
        if let TokenType::Var = &self.peek().token_type() {
            self.advance();
            return Ok(Expr::Variable(VariableExpr {
                name: self.previous().clone(),
            }));
        }
        if self.match_token(TokenType::LeftParen) {
            let paren_open = self.previous().clone();
            let expr = self.expression().inspect_err(|_| {
                self.had_error = true;
                self.synchronize();
            })?;
            if !self.check(&TokenType::RightParen) {
                let error =
                    parser_error::error(self.peek(), "Expected ')' after expression".into());
                self.had_error = true;
                self.synchronize();
                return Err(error);
            }
            self.advance();
            let paren_close = self.previous().clone();
            return Ok(Expr::Grouping(GroupingExpr {
                paren_open,
                expr: Box::new(expr),
                paren_close,
            }));
        }
        // If none of the primary expression types match, it's a parsing error.
        let error = parser_error::error(self.peek(), "Expected expression".into());
        self.had_error = true;
        self.synchronize();
        Err(error)
    }

    /// Checks if the current token's type is one of the provided types and consumes it if it is.
    ///
    /// This method iterates through the given slice of `TokenType`s. If the
    /// current token matches any of these types, the parser advances to the
    /// next token, and the method returns `true`. Otherwise, it returns `false`
    /// without consuming the token.
    ///
    /// # Arguments
    ///
    /// * `types` - A slice of `TokenType`s to check against the current token.
    ///
    /// # Returns
    ///
    /// `true` if the current token's type is in the provided slice and was consumed,
    /// `false` otherwise.
    fn match_tokens(&mut self, types: &[TokenType]) -> bool {
        for t in types {
            if self.check(t) {
                self.advance();
                return true;
            }
        }
        false
    }

    /// Checks if the current token's type is the specified type and consumes it if it is.
    ///
    /// This is a convenience method for `match_tokens` when checking against a single type.
    ///
    /// # Arguments
    ///
    /// * `token_type` - The `TokenType` to check against the current token.
    ///
    /// # Returns
    ///
    /// `true` if the current token's type matches the specified type and was consumed,
    /// `false` otherwise.
    fn match_token(&mut self, token_type: TokenType) -> bool {
        if self.check(&token_type) {
            self.advance();
            return true;
        }
        false
    }

    /// Checks if the current token's type matches the given `TokenType` without consuming it.
    ///
    /// This method looks at the current token without advancing the parser.
    ///
    /// # Arguments
    ///
    /// * `token_type` - The `TokenType` to check against the current token.
    ///
    /// # Returns
    ///
    /// `true` if the current token's type matches the given type, `false` otherwise.
    fn check(&self, token_type: &TokenType) -> bool {
        if self.is_at_end() {
            return false;
        }

        // Compare the discriminants of the token types to ignore associated data
        // for types like Number and String.
        std::mem::discriminant(self.peek().token_type()) == std::mem::discriminant(token_type)
    }

    /// Consumes the current token and advances the parser to the next token.
    ///
    /// If the parser is already at the end of the token stream, this method
    /// does nothing.
    ///
    /// # Returns
    ///
    /// A reference to the token that was just consumed (the token that was
    /// at the `current` position before the advance).
    fn advance(&mut self) -> &Token {
        if !self.is_at_end() {
            self.current += 1;
        }
        self.previous()
    }

    /// Checks if the parser has reached the end of the token stream.
    ///
    /// The end is indicated by the `TokenType::Eof`.
    ///
    /// # Returns
    ///
    /// `true` if the current token is `TokenType::Eof`, `false` otherwise.
    fn is_at_end(&self) -> bool {
        matches!(self.peek().token_type(), TokenType::Eof)
    }

    /// Returns a reference to the current token without consuming it.
    ///
    /// # Returns
    ///
    /// A reference to the `Token` at the current parser position.
    fn peek(&self) -> &Token {
        &self.tokens[self.current]
    }

    /// Returns a reference to the previously consumed token.
    ///
    /// This is the token that was at the `current` position before the last
    /// call to `advance`.
    ///
    /// # Returns
    ///
    /// A reference to the `Token` at the `current - 1` position.
    fn previous(&mut self) -> &Token {
        &self.tokens[self.current - 1]
    }

    /// Attempts to synchronize the parser after an error.
    ///
    /// This method discards tokens until it finds a token that is likely
    /// the start of a new statement, helping the parser recover from errors
    /// and continue parsing the rest of the input. It advances past a semicolon
    /// or until it encounters a keyword that typically starts a new statement.
    fn synchronize(&mut self) {
        self.advance(); // Advance past the token that caused the error

        while !self.is_at_end() {
            // If we see a semicolon, we've reached the end of the previous statement.
            if matches!(self.previous().token_type(), TokenType::Semicolon) {
                return;
            }

            // If we see a keyword that starts a new statement, we can likely
            // resume parsing from there.
            match &self.peek().token_type() {
                TokenType::Class
                | TokenType::Fn
                | TokenType::VarKeyword
                | TokenType::If
                | TokenType::While
                | TokenType::Print
                | TokenType::Return => return,
                _ => {
                    // Otherwise, consume the current token and continue searching.
                    self.advance();
                }
            }
        }
    }

    /// Consumes the current token if its type matches the expected `token_type`.
    ///
    /// If the current token's type matches `token_type`, the parser advances to the next token
    /// and returns a reference to the consumed token.
    /// If the current token's type does not match, a `ParseError` is returned with the
    /// provided `message`.
    ///
    /// # Arguments
    ///
    /// * `token_type`: The expected `TokenType` of the current token.
    /// * `message`: The error message to include in the `ParseError` if the token type
    ///   does not match.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing a reference to the consumed `Token` if the type matches,
    /// otherwise returns a `ParseError`.
    fn consume(&mut self, token_type: TokenType, message: &str) -> Result<&Token, ParseError> {
        if self.check(&token_type) {
            return Ok(self.advance());
        }
        Err(error(self.peek(), message.to_string()))
    }

    /// Parses an `if` statement.
    ///
    /// The structure of an `if` statement is:
    /// `if (condition) then_branch else else_branch`
    /// The `else` branch is optional.
    ///
    /// This function consumes the 'if' keyword, parses the parenthesized condition,
    /// and then parses the `then` branch statement. It then checks for an optional
    /// 'else' keyword and parses the `else` branch statement if present.
    fn if_statment(&mut self) -> Result<Stmt, ParseError> {
        // step over the if
        self.advance();

        self.consume(TokenType::LeftParen, "Expect '(' after if.")?;

        let condition = self.expression()?;

        self.consume(TokenType::RightParen, "Expect ')' after if.")?;

        let then_branch = Box::new(self.statement()?);
        let else_branch = if self.check(&TokenType::Else) {
            self.advance();
            Some(Box::new(self.statement()?))
        } else {
            None
        };

        Ok(Stmt::If(IfStmt {
            condition,
            then_branch,
            else_branch,
        }))
    }

    /// This function checks which kind of Statement a token is and returns it or throws a parsing
    /// error
    fn statement(&mut self) -> Result<Stmt, ParseError> {
        match self.peek().token_type() {
            TokenType::Print => self.print_statement(),
            TokenType::LeftBrace => self.block_statement(),
            TokenType::If => self.if_statment(),
            TokenType::While => self.while_statment(),
            TokenType::For => self.for_statement(),
            _ => self.expression_statement(),
        }
    }

    /// Parses a declaration, which can be a variable declaration or any other statement.
    ///
    /// This function peeks at the current token to determine if it's a `var` keyword.
    /// If it is, it calls `variable_declaration` to parse a variable declaration.
    /// Otherwise, it calls `statement` to parse any other type of statement.
    ///
    /// After attempting to parse a declaration, it includes error handling to synchronize
    /// the parser's state in case of an error.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing the parsed `Stmt` if successful.
    /// If a `ParseError` occurs during parsing, the parser's state is synchronized,
    /// and the error is returned.
    fn declaration(&mut self) -> Result<Stmt, ParseError> {
        match self.peek().token_type() {
            TokenType::VarKeyword => self.variable_declaration(),
            _ => self.statement(),
        }
        .inspect_err(|_| {
            self.synchronize();
        })
    }

    /// Parses a `for` statement.
    ///
    /// The structure of a `for` loop is:
    /// `for (initializer; condition; increment) { body }`
    ///
    /// The initializer, condition, and increment are all optional.
    ///
    /// This function consumes the 'for' keyword, parses the parenthesized clauses,
    /// and then parses the loop body. It then transforms the `for` loop
    /// into a `while` loop with an optional initializer and increment.
    fn for_statement(&mut self) -> Result<Stmt, ParseError> {
        self.advance(); // Consume 'for'

        self.consume(TokenType::LeftParen, "Expect '(' after 'for'.")?;

        let initializer = if self.match_token(TokenType::Semicolon) {
            None
        } else if self.check(&TokenType::VarKeyword) {
            Some(self.variable_declaration()?)
        } else {
            Some(self.expression_statement()?)
        };

        let condition = if !self.check(&TokenType::Semicolon) {
            Some(self.expression()?)
        } else {
            None
        };
        self.consume(TokenType::Semicolon, "Expect ';' after loop condition.")?;

        let increment = if !self.check(&TokenType::RightParen) {
            Some(self.expression()?)
        } else {
            None
        };
        self.consume(TokenType::RightParen, "Expect ')' after for clauses.")?;

        let mut body = self.statement()?;

        if let Some(inc) = increment {
            body = Stmt::Block(vec![body, Stmt::Expression(inc)]);
        }

        body = Stmt::While(WhileStmt {
            condition: condition.unwrap_or(Expr::Literal(LiteralExpr {
                literal: Token::new(
                    TokenType::True,
                    "true",
                    Some(Object::Boolean(true)),
                    self.peek().line(),
                ),
            })),
            body: Box::new(body),
        });

        if let Some(init) = initializer {
            body = Stmt::Block(vec![init, body]);
        }

        Ok(body)
    }

    /// Parses a `while` statement.
    ///
    /// The structure of a `while` loop is:
    /// `while (condition) { body }`
    ///
    /// This function consumes the 'while' keyword, parses the parenthesized condition,
    /// and then parses the loop body.
    ///
    fn while_statment(&mut self) -> Result<Stmt, ParseError> {
        // step over the while
        self.advance();

        self.consume(TokenType::LeftParen, "Expect '(' after while.")?;

        let condition = self.expression()?;

        self.consume(TokenType::RightParen, "Expect ')' after while.")?;

        let body = Box::new(self.statement()?);

        Ok(Stmt::While(WhileStmt { condition, body }))
    }

    fn variable_declaration(&mut self) -> Result<Stmt, ParseError> {
        self.advance();
        let name: Token = if self.match_token(TokenType::Var) {
            self.previous().clone()
        } else {
            return Err(error(
                self.peek(),
                "Token is not a variable identifier".to_string(),
            ));
        };

        let initializer: Option<Expr> = if self.match_token(TokenType::Equal) {
            Some(self.expression()?)
        } else {
            None
        };

        if !self.match_token(TokenType::Semicolon) {
            return Err(error(
                self.peek(),
                "Expect ';' after expression.".to_string(),
            ));
        } else {
            Ok(Stmt::Var(VarStmt { name, initializer }))
        }
    }

    /// Returns a 'Stmt::Print' statement after evaluating the expression signaling to the
    /// StmtVisitor to print the result
    fn print_statement(&mut self) -> Result<Stmt, ParseError> {
        // advance to skip print
        self.advance();

        let val: Expr = self.expression()?;

        self.consume(TokenType::Semicolon, "Expect ';' after expression.")?;

        Ok(Stmt::Print(val))
    }

    /// Generates a block statement and generates a 'Stmt::Block' which evaluates to a list of
    /// other statments
    fn block_statement(&mut self) -> Result<Stmt, ParseError> {
        // advance past the opening brace
        self.advance();

        let mut statements = Vec::new();

        while !self.check(&TokenType::RightBrace) && !self.is_at_end() {
            statements.push(self.declaration()?);
        }

        self.consume(TokenType::RightBrace, "Expect '}' after block.")?;
        Ok(Stmt::Block(statements))
    }

    /// Evaluates the expression and returns it as a 'Stmt::Expression'
    fn expression_statement(&mut self) -> Result<Stmt, ParseError> {
        let val: Expr = self.expression()?;

        self.consume(TokenType::Semicolon, "Expect ';' after expression.")?;

        Ok(Stmt::Expression(val))
    }
}

/// Parses a list of tokens into an abstract syntax tree (AST).
///
/// This parses a series of statements, as many as it can find until it hits the end of the input
///
/// This is a convenience function that creates a `Parser` instance and
/// calls its `parse` method.
///
/// # Arguments
///
/// * `token_input` - A `Vec<Token>` representing the input tokens.
///
/// # Returns
///
/// A `Result` containing a `Vec<Stmt>` representing the roots of the AST on
/// successful parsing without errors, or a `String` containing an error message
/// if parsing failed or completed with errors.
pub fn parse(token_input: Vec<Token>) -> Result<Vec<Stmt>, Vec<ParseError>> {
    let mut stmts: Vec<Stmt> = Vec::new();
    let mut parser = Parser::new(token_input);
    let mut parser_errors: Vec<ParseError> = Vec::new();

    while !parser.is_at_end() {
        match parser.declaration() {
            Ok(statement) => stmts.push(statement),
            Err(error) => {
                parser.had_error = true;
                parser_errors.push(error);
            }
        }
    }

    Ok(stmts)
}

#[cfg(test)]
mod tests {}
