use crate::expr_types::*;
use crate::parser_error::{self, error, ParseError};
use crate::stmt_types::{IfStmt, Stmt, VarStmt};
use crate::token::TokenType;
use crate::Token;

/// A recursive descent parser that takes a list of tokens and generates an abstract syntax tree (AST).
///
/// The parser follows the grammar of the language to construct an AST representation
/// of the input code. It handles operator precedence and associativity through
/// a series of parsing methods.
///
/// expression     → equality ;
/// equality       → comparison ( ( "!=" | "==" ) comparison )* ;
/// comparison     → term ( ( ">" | ">=" | "<" | "<=" ) term )* ;
/// term           → factor ( ( "-" | "+" ) factor )* ;
/// factor         → unary ( ( "/" | "*" ) unary )* ;
/// unary          → ( "!" | "-" ) unary | primary ;
/// primary        → NUMBER | STRING | "true" | "false" | "nil" | "(" expression ")" ;

pub struct Parser {
    /// The list of tokens generated by the scanner.
    tokens: Vec<Token>,
    /// The index of the current token being considered.
    current: usize,
    /// A flag indicating whether a parsing error has occurred.
    had_error: bool,
}

impl Parser {
    /// Creates a new `Parser` with the given list of tokens.
    ///
    /// # Arguments
    ///
    /// * `tokens` - A `Vec<Token>` representing the input tokens.
    pub fn new(tokens: Vec<Token>) -> Self {
        Parser {
            tokens,
            current: 0,
            had_error: false,
        }
    }

    /// Starts the parsing process and returns the root of the abstract syntax tree.
    ///
    /// This method attempts to parse the entire token stream as an expression.
    /// It returns a boxed `Expr` representing the root of the AST on success.
    /// If any parsing errors occur, it returns an error message.
    ///
    /// # Returns
    ///
    /// A `Result` containing a `Box<Expr>` on successful parsing without errors,
    /// or a `String` containing an error message if parsing failed or completed
    /// with errors.
    pub fn parse(&mut self) -> Result<Box<Expr>, String> {
        match self.expression() {
            Ok(expr) if !self.had_error => Ok(Box::new(expr)),
            Ok(_) => Err("Parsing completed with errors.".into()),
            Err(e) => Err(format!("Parsing error: {}", e.message)), // Assuming ParseError has a display implementation or access to message
        }
    }

    /// Parses an expression according to the language's grammar.
    ///
    /// This method is the entry point for parsing expressions. It delegates
    /// to the `equality` method, which handles the lowest precedence operator.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` on success, or a `ParseError` if a
    /// parsing error occurs during the expression parsing.
    fn expression(&mut self) -> Result<Expr, ParseError> {
        self.assignment()
    }

    fn assignment(&mut self) -> Result<Expr, ParseError> {
        let expr = self.equality()?;

        if self.match_token(TokenType::Equal) {
            let equals = self.previous().clone();
            let value = self.assignment()?;

            match expr {
                Expr::Variable(var_expr) => {
                    return Ok(Expr::Assign(AssignExpr {
                        name: var_expr.name,
                        value: Box::new(value),
                    }))
                }
                _ => return Err(error(&equals, "Invalid assignment target.".to_string())),
            }
        }

        return Ok(expr);
    }

    /// Parses an equality expression (`==`, `!=`).
    ///
    /// This method parses a comparison expression and then checks for
    /// equality or inequality operators, building binary expression nodes
    /// as needed.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` representing the parsed equality
    /// expression, or a `ParseError` if an error occurs.
    fn equality(&mut self) -> Result<Expr, ParseError> {
        let mut expr = self.comparison()?;
        while self.match_tokens(&[TokenType::BangEqual, TokenType::EqualEqual]) {
            let operator = self.previous().clone();
            let right = self.comparison().map_err(|e| {
                self.had_error = true;
                self.synchronize();
                e
            })?;
            expr = Expr::Binary(BinaryExpr {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            });
        }
        Ok(expr)
    }

    /// Parses a comparison expression (`>`, `>=`, `<`, `<=`).
    ///
    /// This method parses a term and then checks for comparison operators,
    /// building binary expression nodes as needed.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` representing the parsed comparison
    /// expression, or a `ParseError` if an error occurs.
    fn comparison(&mut self) -> Result<Expr, ParseError> {
        let mut expr = self.term()?;
        while self.match_tokens(&[
            TokenType::Greater,
            TokenType::GreaterEqual,
            TokenType::Less,
            TokenType::LessEqual,
        ]) {
            let operator = self.previous().clone();
            let right = self.term().map_err(|e| {
                self.had_error = true;
                self.synchronize();
                e
            })?;
            expr = Expr::Binary(BinaryExpr {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            });
        }
        Ok(expr)
    }

    /// Parses an additive expression (`+`, `-`).
    ///
    /// This method parses a factor and then checks for additive operators,
    /// building binary expression nodes as needed.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` representing the parsed additive
    /// expression, or a `ParseError` if an error occurs.
    fn term(&mut self) -> Result<Expr, ParseError> {
        let mut expr = self.factor()?;
        while self.match_tokens(&[TokenType::Minus, TokenType::Plus]) {
            let operator = self.previous().clone();
            let right = self.factor().map_err(|e| {
                self.had_error = true;
                self.synchronize();
                e
            })?;
            expr = Expr::Binary(BinaryExpr {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            });
        }
        Ok(expr)
    }

    /// Parses a multiplicative expression (`*`, `/`).
    ///
    /// This method parses a unary expression and then checks for multiplicative
    /// operators, building binary expression nodes as needed.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` representing the parsed multiplicative
    /// expression, or a `ParseError` if an error occurs.
    fn factor(&mut self) -> Result<Expr, ParseError> {
        let mut expr = self.unary()?;
        while self.match_tokens(&[TokenType::Slash, TokenType::Asterisk]) {
            let operator = self.previous().clone();
            let right = self.unary().map_err(|e| {
                self.had_error = true;
                self.synchronize();
                e
            })?;
            expr = Expr::Binary(BinaryExpr {
                left: Box::new(expr),
                operator,
                right: Box::new(right),
            });
        }
        Ok(expr)
    }

    /// Parses a unary expression (`!`, `-`).
    ///
    /// This method checks for unary operators (`!` or `-`) and, if found,
    /// recursively parses the operand. Otherwise, it delegates to `primary`.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` representing the parsed unary
    /// expression or the result of `primary`, or a `ParseError` if an
    /// error occurs.
    fn unary(&mut self) -> Result<Expr, ParseError> {
        if self.match_tokens(&[TokenType::Bang, TokenType::Minus]) {
            let prefix = self.previous().clone();
            let operator = self.unary().map_err(|e| {
                self.had_error = true;
                self.synchronize();
                e
            })?;
            return Ok(Expr::Unary(UnaryExpr {
                prefix,
                operator: Box::new(operator),
            }));
        }
        self.primary()
    }

    /// Parses the highest precedence expressions: literals, grouping, and variables.
    ///
    /// This method handles boolean literals (`true`, `false`, `nil`), number
    /// and string literals, parenthesized expressions, and variable references.
    ///
    /// # Returns
    ///
    /// A `Result` containing an `Expr` representing the parsed primary
    /// expression, or a `ParseError` if an error occurs (e.g., unexpected token).
    fn primary(&mut self) -> Result<Expr, ParseError> {
        if self.match_tokens(&[TokenType::False, TokenType::True, TokenType::Nil]) {
            return Ok(Expr::Literal(LiteralExpr {
                literal: self.previous().clone(),
            }));
        }
        if let TokenType::Number = &self.peek().token_type() {
            self.advance();
            return Ok(Expr::Literal(LiteralExpr {
                literal: self.previous().clone(),
            }));
        }
        if let TokenType::String = &self.peek().token_type() {
            self.advance();
            return Ok(Expr::Literal(LiteralExpr {
                literal: self.previous().clone(),
            }));
        }
        if let TokenType::Var = &self.peek().token_type() {
            self.advance();
            return Ok(Expr::Variable(VariableExpr {
                name: self.previous().clone(),
            }));
        }
        if self.match_token(TokenType::LeftParen) {
            let paren_open = self.previous().clone();
            let expr = self.expression().map_err(|e| {
                self.had_error = true;
                self.synchronize();
                e
            })?;
            if !self.check(&TokenType::RightParen) {
                let error =
                    parser_error::error(self.peek(), "Expected ')' after expression".into());
                self.had_error = true;
                self.synchronize();
                return Err(error);
            }
            self.advance();
            let paren_close = self.previous().clone();
            return Ok(Expr::Grouping(GroupingExpr {
                paren_open,
                expr: Box::new(expr),
                paren_close,
            }));
        }
        // If none of the primary expression types match, it's a parsing error.
        let error = parser_error::error(self.peek(), "Expected expression".into());
        self.had_error = true;
        self.synchronize();
        Err(error)
    }

    /// Checks if the current token's type is one of the provided types and consumes it if it is.
    ///
    /// This method iterates through the given slice of `TokenType`s. If the
    /// current token matches any of these types, the parser advances to the
    /// next token, and the method returns `true`. Otherwise, it returns `false`
    /// without consuming the token.
    ///
    /// # Arguments
    ///
    /// * `types` - A slice of `TokenType`s to check against the current token.
    ///
    /// # Returns
    ///
    /// `true` if the current token's type is in the provided slice and was consumed,
    /// `false` otherwise.
    fn match_tokens(&mut self, types: &[TokenType]) -> bool {
        for t in types {
            if self.check(t) {
                self.advance();
                return true;
            }
        }
        false
    }

    /// Checks if the current token's type is the specified type and consumes it if it is.
    ///
    /// This is a convenience method for `match_tokens` when checking against a single type.
    ///
    /// # Arguments
    ///
    /// * `token_type` - The `TokenType` to check against the current token.
    ///
    /// # Returns
    ///
    /// `true` if the current token's type matches the specified type and was consumed,
    /// `false` otherwise.
    fn match_token(&mut self, token_type: TokenType) -> bool {
        if self.check(&token_type) {
            self.advance();
            return true;
        }
        false
    }

    /// Checks if the current token's type matches the given `TokenType` without consuming it.
    ///
    /// This method looks at the current token without advancing the parser.
    ///
    /// # Arguments
    ///
    /// * `token_type` - The `TokenType` to check against the current token.
    ///
    /// # Returns
    ///
    /// `true` if the current token's type matches the given type, `false` otherwise.
    fn check(&self, token_type: &TokenType) -> bool {
        if self.is_at_end() {
            return false;
        }

        // Compare the discriminants of the token types to ignore associated data
        // for types like Number and String.
        std::mem::discriminant(self.peek().token_type()) == std::mem::discriminant(token_type)
    }

    /// Consumes the current token and advances the parser to the next token.
    ///
    /// If the parser is already at the end of the token stream, this method
    /// does nothing.
    ///
    /// # Returns
    ///
    /// A reference to the token that was just consumed (the token that was
    /// at the `current` position before the advance).
    fn advance(&mut self) -> &Token {
        if !self.is_at_end() {
            self.current += 1;
        }
        self.previous()
    }

    /// Checks if the parser has reached the end of the token stream.
    ///
    /// The end is indicated by the `TokenType::EOF`.
    ///
    /// # Returns
    ///
    /// `true` if the current token is `TokenType::EOF`, `false` otherwise.
    fn is_at_end(&self) -> bool {
        matches!(self.peek().token_type(), TokenType::EOF)
    }

    /// Returns a reference to the current token without consuming it.
    ///
    /// # Returns
    ///
    /// A reference to the `Token` at the current parser position.
    fn peek(&self) -> &Token {
        &self.tokens[self.current]
    }

    /// Returns a reference to the previously consumed token.
    ///
    /// This is the token that was at the `current` position before the last
    /// call to `advance`.
    ///
    /// # Returns
    ///
    /// A reference to the `Token` at the `current - 1` position.
    fn previous(&mut self) -> &Token {
        &self.tokens[self.current - 1]
    }

    /// Attempts to synchronize the parser after an error.
    ///
    /// This method discards tokens until it finds a token that is likely
    /// the start of a new statement, helping the parser recover from errors
    /// and continue parsing the rest of the input. It advances past a semicolon
    /// or until it encounters a keyword that typically starts a new statement.
    fn synchronize(&mut self) {
        self.advance(); // Advance past the token that caused the error

        while !self.is_at_end() {
            // If we see a semicolon, we've reached the end of the previous statement.
            if matches!(self.previous().token_type(), TokenType::Semicolon) {
                return;
            }

            // If we see a keyword that starts a new statement, we can likely
            // resume parsing from there.
            match &self.peek().token_type() {
                TokenType::Class
                | TokenType::Fn
                | TokenType::VarKeyword
                | TokenType::If
                | TokenType::While
                | TokenType::Print
                | TokenType::Return => return,
                _ => {
                    // Otherwise, consume the current token and continue searching.
                    self.advance();
                }
            }
        }
    }
}

/// Parses a list of tokens into an abstract syntax tree (AST).
///
/// This parses a series of statements, as many as it can find until it hits the end of the input
///
/// This is a convenience function that creates a `Parser` instance and
/// calls its `parse` method.
///
/// # Arguments
///
/// * `token_input` - A `Vec<Token>` representing the input tokens.
///
/// # Returns
///
/// A `Result` containing a `Vec<Stmt>` representing the roots of the AST on
/// successful parsing without errors, or a `String` containing an error message
/// if parsing failed or completed with errors.
pub fn parse(token_input: Vec<Token>) -> Result<Vec<Stmt>, Vec<ParseError>> {
    let mut stmts: Vec<Stmt> = Vec::new();
    let mut parser = Parser::new(token_input);
    let mut parser_errors: Vec<ParseError> = Vec::new();

    while !parser.is_at_end() {
        match declaration(&mut parser) {
            Ok(statement) => stmts.push(statement),
            Err(error) => {
                parser.had_error = true;
                parser_errors.push(error);
            }
        }
    }

    Ok(stmts)
}

fn declaration(parser: &mut Parser) -> Result<Stmt, ParseError> {
    match parser.peek().token_type() {
        TokenType::VarKeyword => variable_declaration(parser),
        _ => statement(parser),
    }
    .map_err(|e| {
        parser.synchronize();
        e
    })
}

/// This function checks which kind of Statement a token is and returns it or throws a parsing
/// error
fn statement(parser: &mut Parser) -> Result<Stmt, ParseError> {
    match parser.peek().token_type() {
        TokenType::Print => print_statement(parser),
        TokenType::LeftBrace => block_statement(parser),
        TokenType::If => if_statment(parser),
        _ => expression_statement(parser),
    }
}

fn variable_declaration(parser: &mut Parser) -> Result<Stmt, ParseError> {
    parser.advance();
    let name: Token = if parser.match_token(TokenType::Var) {
        parser.previous().clone()
    } else {
        return Err(error(
            parser.peek(),
            "Token is not a variable identifier".to_string(),
        ));
    };

    let initializer: Option<Expr> = if parser.match_token(TokenType::Equal) {
        Some(parser.expression()?)
    } else {
        None
    };

    if !parser.match_token(TokenType::Semicolon) {
        return Err(error(
            parser.peek(),
            "Expect ';' after expression.".to_string(),
        ));
    } else {
        Ok(Stmt::Var(VarStmt { name, initializer }))
    }
}

/// Returns a 'Stmt::Print' statement after evaluating the expression signaling to the
/// StmtVisitor to print the result
fn print_statement(parser: &mut Parser) -> Result<Stmt, ParseError> {
    // advance to skip print
    parser.advance();

    let val: Expr = parser.expression()?;
    if !parser.match_token(TokenType::Semicolon) {
        return Err(error(
            parser.peek(),
            "Expect ';' after expression.".to_string(),
        ));
    }

    Ok(Stmt::Print(val))
}

fn block_statement(parser: &mut Parser) -> Result<Stmt, ParseError> {
    // advance past the opening brace
    parser.advance();

    let mut statements = Vec::new();

    while !parser.check(&TokenType::RightBrace) && !parser.is_at_end() {
        statements.push(declaration(parser)?);
    }

    if parser.check(&TokenType::RightBrace) {
        parser.advance();

        Ok(Stmt::Block(statements))
    } else {
        Err(error(parser.peek(), "Expect '}' after block.".to_string()))
    }
}

/// Evaluates the expression and returns it as a 'Stmt::Expression'
fn expression_statement(parser: &mut Parser) -> Result<Stmt, ParseError> {
    let val: Expr = parser.expression()?;
    if !parser.match_token(TokenType::Semicolon) {
        return Err(error(
            parser.peek(),
            "Expect ';' after expression.".to_string(),
        ));
    }

    Ok(Stmt::Expression(val))
}

fn if_statment(parser: &mut Parser) -> Result<Stmt, ParseError> {
    // step over the if
    parser.advance();
    if !parser.check(&TokenType::LeftParen) {
        return Err(error(parser.peek(), "Expect '(' before if.".to_string()));
    }
    parser.advance();

    let condition = parser.expression()?;

    if !parser.check(&TokenType::RightParen) {
        return Err(error(parser.peek(), "Expect ')' after 'if'.".to_string()));
    }
    parser.advance();

    let then_branch = Box::new(statement(parser)?);
    let else_branch = if parser.check(&TokenType::Else) {
        parser.advance();
        Some(Box::new(statement(parser)?))
    } else {
        None
    };

    Ok(Stmt::If(IfStmt {
        condition,
        then_branch,
        else_branch,
    }))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::object::Object;
    use crate::token::{Token, TokenType};

    fn create_token(
        token_type: TokenType,
        lexeme: &str,
        line: u64,
        literal: Option<Object>,
    ) -> Token {
        Token::new(token_type, lexeme, literal, line)
    }

    fn create_eof(line: u64) -> Token {
        create_token(TokenType::EOF, "", line, None)
    }

    #[test]
    fn test_parse_number_literal() {
        let tokens = vec![
            create_token(TokenType::Number, "123", 1, Some(Object::Number(123.0))),
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let expr = parser.parse().unwrap();

        match expr.as_ref() {
            Expr::Literal(lit) => match lit.literal.literal() {
                Some(Object::Number(val)) => assert_eq!(*val, 123.0),
                _ => panic!("Expected number literal"),
            },
            _ => panic!("Expected literal expression"),
        }
    }

    #[test]
    fn test_parse_string_literal() {
        let tokens = vec![
            create_token(
                TokenType::String,
                "\"hello\"",
                1,
                Some(Object::String("hello".to_string())),
            ),
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let expr = parser.parse().unwrap();

        match expr.as_ref() {
            Expr::Literal(lit) => match lit.literal.literal() {
                Some(Object::String(val)) => assert_eq!(val, "hello"),
                _ => panic!("Expected string literal"),
            },
            _ => panic!("Expected literal expression"),
        }
    }

    #[test]
    fn test_parse_boolean_literals() {
        // Test true
        let tokens = vec![
            create_token(TokenType::True, "true", 1, Some(Object::Boolean(true))),
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let expr = parser.parse().unwrap();

        match expr.as_ref() {
            Expr::Literal(lit) => match lit.literal.literal() {
                Some(Object::Boolean(val)) => assert!(*val),
                _ => panic!("Expected boolean literal"),
            },
            _ => panic!("Expected literal expression"),
        }

        // Test false
        let tokens = vec![
            create_token(TokenType::False, "false", 1, Some(Object::Boolean(false))),
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let expr = parser.parse().unwrap();

        match expr.as_ref() {
            Expr::Literal(lit) => match lit.literal.literal() {
                Some(Object::Boolean(val)) => assert!(!(*val)),
                _ => panic!("Expected boolean literal"),
            },
            _ => panic!("Expected literal expression"),
        }
    }

    #[test]
    fn test_parse_nil_literal() {
        let tokens = vec![
            create_token(TokenType::Nil, "nil", 1, Some(Object::Nil)),
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let expr = parser.parse().unwrap();

        match expr.as_ref() {
            Expr::Literal(lit) => match lit.literal.literal() {
                Some(Object::Nil) => {}
                _ => panic!("Expected nil literal"),
            },
            _ => panic!("Expected literal expression"),
        }
    }

    #[test]
    fn test_parse_grouping() {
        let tokens = vec![
            create_token(TokenType::LeftParen, "(", 1, None),
            create_token(TokenType::Number, "123", 1, Some(Object::Number(123.0))),
            create_token(TokenType::RightParen, ")", 1, None),
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let expr = parser.parse().unwrap();

        match expr.as_ref() {
            Expr::Grouping(group) => match group.expr.as_ref() {
                Expr::Literal(lit) => match lit.literal.literal() {
                    Some(Object::Number(val)) => assert_eq!(*val, 123.0),
                    _ => panic!("Expected number literal inside grouping"),
                },
                _ => panic!("Expected literal expression inside grouping"),
            },
            _ => panic!("Expected grouping expression"),
        }
    }

    #[test]
    fn test_parse_unary_minus() {
        let tokens = vec![
            create_token(TokenType::Minus, "-", 1, None),
            create_token(TokenType::Number, "123", 1, Some(Object::Number(123.0))),
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let expr = parser.parse().unwrap();

        match expr.as_ref() {
            Expr::Unary(unary) => {
                assert!(matches!(unary.prefix.token_type(), TokenType::Minus));
                match unary.operator.as_ref() {
                    Expr::Literal(lit) => match lit.literal.literal() {
                        Some(Object::Number(val)) => assert_eq!(*val, 123.0),
                        _ => panic!("Expected number literal in unary expression"),
                    },
                    _ => panic!("Expected literal expression in unary operator"),
                }
            }
            _ => panic!("Expected unary expression"),
        }
    }

    #[test]
    fn test_parse_unary_bang() {
        let tokens = vec![
            create_token(TokenType::Bang, "!", 1, None),
            create_token(TokenType::True, "true", 1, Some(Object::Boolean(true))),
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let expr = parser.parse().unwrap();

        match expr.as_ref() {
            Expr::Unary(unary) => {
                assert!(matches!(unary.prefix.token_type(), TokenType::Bang));
                match unary.operator.as_ref() {
                    Expr::Literal(lit) => match lit.literal.literal() {
                        Some(Object::Boolean(val)) => assert!(*val),
                        _ => panic!("Expected boolean literal in unary expression"),
                    },
                    _ => panic!("Expected literal expression in unary operator"),
                }
            }
            _ => panic!("Expected unary expression"),
        }
    }

    #[test]
    fn test_parse_binary_addition() {
        let tokens = vec![
            create_token(TokenType::Number, "1", 1, Some(Object::Number(1.0))),
            create_token(TokenType::Plus, "+", 1, None),
            create_token(TokenType::Number, "2", 1, Some(Object::Number(2.0))),
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let expr = parser.parse().unwrap();

        match expr.as_ref() {
            Expr::Binary(binary) => {
                assert!(matches!(binary.operator.token_type(), TokenType::Plus));

                match binary.left.as_ref() {
                    Expr::Literal(lit) => match lit.literal.literal() {
                        Some(Object::Number(val)) => assert_eq!(*val, 1.0),
                        _ => panic!("Expected number literal for left operand"),
                    },
                    _ => panic!("Expected literal expression for left operand"),
                }

                match binary.right.as_ref() {
                    Expr::Literal(lit) => match lit.literal.literal() {
                        Some(Object::Number(val)) => assert_eq!(*val, 2.0),
                        _ => panic!("Expected number literal for right operand"),
                    },
                    _ => panic!("Expected literal expression for right operand"),
                }
            }
            _ => panic!("Expected binary expression"),
        }
    }

    #[test]
    fn test_parse_binary_subtraction() {
        let tokens = vec![
            create_token(TokenType::Number, "5", 1, Some(Object::Number(5.0))),
            create_token(TokenType::Minus, "-", 1, None),
            create_token(TokenType::Number, "3", 1, Some(Object::Number(3.0))),
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let expr = parser.parse().unwrap();

        match expr.as_ref() {
            Expr::Binary(binary) => {
                assert!(matches!(binary.operator.token_type(), TokenType::Minus));

                match binary.left.as_ref() {
                    Expr::Literal(lit) => match lit.literal.literal() {
                        Some(Object::Number(val)) => assert_eq!(*val, 5.0),
                        _ => panic!("Expected number literal for left operand"),
                    },
                    _ => panic!("Expected literal expression for left operand"),
                }

                match binary.right.as_ref() {
                    Expr::Literal(lit) => match lit.literal.literal() {
                        Some(Object::Number(val)) => assert_eq!(*val, 3.0),
                        _ => panic!("Expected number literal for right operand"),
                    },
                    _ => panic!("Expected literal expression for right operand"),
                }
            }
            _ => panic!("Expected binary expression"),
        }
    }

    #[test]
    fn test_parse_binary_multiplication() {
        let tokens = vec![
            create_token(TokenType::Number, "2", 1, Some(Object::Number(2.0))),
            create_token(TokenType::Asterisk, "*", 1, None),
            create_token(TokenType::Number, "3", 1, Some(Object::Number(3.0))),
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let expr = parser.parse().unwrap();

        match expr.as_ref() {
            Expr::Binary(binary) => {
                assert!(matches!(binary.operator.token_type(), TokenType::Asterisk));

                match binary.left.as_ref() {
                    Expr::Literal(lit) => match lit.literal.literal() {
                        Some(Object::Number(val)) => assert_eq!(*val, 2.0),
                        _ => panic!("Expected number literal for left operand"),
                    },
                    _ => panic!("Expected literal expression for left operand"),
                }

                match binary.right.as_ref() {
                    Expr::Literal(lit) => match lit.literal.literal() {
                        Some(Object::Number(val)) => assert_eq!(*val, 3.0),
                        _ => panic!("Expected number literal for right operand"),
                    },
                    _ => panic!("Expected literal expression for right operand"),
                }
            }
            _ => panic!("Expected binary expression"),
        }
    }

    #[test]
    fn test_parse_binary_division() {
        let tokens = vec![
            create_token(TokenType::Number, "6", 1, Some(Object::Number(6.0))),
            create_token(TokenType::Slash, "/", 1, None),
            create_token(TokenType::Number, "2", 1, Some(Object::Number(2.0))),
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let expr = parser.parse().unwrap();

        match expr.as_ref() {
            Expr::Binary(binary) => {
                assert!(matches!(binary.operator.token_type(), TokenType::Slash));

                match binary.left.as_ref() {
                    Expr::Literal(lit) => match lit.literal.literal() {
                        Some(Object::Number(val)) => assert_eq!(*val, 6.0),
                        _ => panic!("Expected number literal for left operand"),
                    },
                    _ => panic!("Expected literal expression for left operand"),
                }

                match binary.right.as_ref() {
                    Expr::Literal(lit) => match lit.literal.literal() {
                        Some(Object::Number(val)) => assert_eq!(*val, 2.0),
                        _ => panic!("Expected number literal for right operand"),
                    },
                    _ => panic!("Expected literal expression for right operand"),
                }
            }
            _ => panic!("Expected binary expression"),
        }
    }

    #[test]
    fn test_parse_comparison_operators() {
        // Test >
        let tokens = vec![
            create_token(TokenType::Number, "5", 1, Some(Object::Number(5.0))),
            create_token(TokenType::Greater, ">", 1, None),
            create_token(TokenType::Number, "3", 1, Some(Object::Number(3.0))),
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let expr = parser.parse().unwrap();

        match expr.as_ref() {
            Expr::Binary(binary) => {
                assert!(matches!(binary.operator.token_type(), TokenType::Greater));
            }
            _ => panic!("Expected binary expression with > operator"),
        }

        // Test >=
        let tokens = vec![
            create_token(TokenType::Number, "5", 1, Some(Object::Number(5.0))),
            create_token(TokenType::GreaterEqual, ">=", 1, None),
            create_token(TokenType::Number, "5", 1, Some(Object::Number(5.0))),
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let expr = parser.parse().unwrap();

        match expr.as_ref() {
            Expr::Binary(binary) => {
                assert!(matches!(
                    binary.operator.token_type(),
                    TokenType::GreaterEqual
                ));
            }
            _ => panic!("Expected binary expression with >= operator"),
        }

        // Test <
        let tokens = vec![
            create_token(TokenType::Number, "3", 1, Some(Object::Number(3.0))),
            create_token(TokenType::Less, "<", 1, None),
            create_token(TokenType::Number, "5", 1, Some(Object::Number(5.0))),
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let expr = parser.parse().unwrap();

        match expr.as_ref() {
            Expr::Binary(binary) => {
                assert!(matches!(binary.operator.token_type(), TokenType::Less));
            }
            _ => panic!("Expected binary expression with < operator"),
        }

        // Test <=
        let tokens = vec![
            create_token(TokenType::Number, "5", 1, Some(Object::Number(5.0))),
            create_token(TokenType::LessEqual, "<=", 1, None),
            create_token(TokenType::Number, "5", 1, Some(Object::Number(5.0))),
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let expr = parser.parse().unwrap();

        match expr.as_ref() {
            Expr::Binary(binary) => {
                assert!(matches!(binary.operator.token_type(), TokenType::LessEqual));
            }
            _ => panic!("Expected binary expression with <= operator"),
        }
    }

    #[test]
    fn test_parse_equality_operators() {
        // Test ==
        let tokens = vec![
            create_token(TokenType::Number, "5", 1, Some(Object::Number(5.0))),
            create_token(TokenType::EqualEqual, "==", 1, None),
            create_token(TokenType::Number, "5", 1, Some(Object::Number(5.0))),
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let expr = parser.parse().unwrap();

        match expr.as_ref() {
            Expr::Binary(binary) => {
                assert!(matches!(
                    binary.operator.token_type(),
                    TokenType::EqualEqual
                ));
            }
            _ => panic!("Expected binary expression with == operator"),
        }

        // Test !=
        let tokens = vec![
            create_token(TokenType::Number, "5", 1, Some(Object::Number(5.0))),
            create_token(TokenType::BangEqual, "!=", 1, None),
            create_token(TokenType::Number, "3", 1, Some(Object::Number(3.0))),
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let expr = parser.parse().unwrap();

        match expr.as_ref() {
            Expr::Binary(binary) => {
                assert!(matches!(binary.operator.token_type(), TokenType::BangEqual));
            }
            _ => panic!("Expected binary expression with != operator"),
        }
    }

    #[test]
    fn test_parse_complex_expression() {
        // Test 1 + 2 * 3
        let tokens = vec![
            create_token(TokenType::Number, "1", 1, Some(Object::Number(1.0))),
            create_token(TokenType::Plus, "+", 1, None),
            create_token(TokenType::Number, "2", 1, Some(Object::Number(2.0))),
            create_token(TokenType::Asterisk, "*", 1, None),
            create_token(TokenType::Number, "3", 1, Some(Object::Number(3.0))),
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let expr = parser.parse().unwrap();

        // Should parse as (1 + (2 * 3)) due to operator precedence
        match expr.as_ref() {
            Expr::Binary(binary) => {
                assert!(matches!(binary.operator.token_type(), TokenType::Plus));

                match binary.left.as_ref() {
                    Expr::Literal(lit) => match lit.literal.literal() {
                        Some(Object::Number(val)) => assert_eq!(*val, 1.0),
                        _ => panic!("Expected number literal for left operand"),
                    },
                    _ => panic!("Expected literal expression for left operand"),
                }

                match binary.right.as_ref() {
                    Expr::Binary(inner_binary) => {
                        assert!(matches!(
                            inner_binary.operator.token_type(),
                            TokenType::Asterisk
                        ));
                    }
                    _ => panic!("Expected binary expression for right operand"),
                }
            }
            _ => panic!("Expected binary expression"),
        }
    }

    #[test]
    fn test_parse_error_missing_paren() {
        let tokens = vec![
            create_token(TokenType::LeftParen, "(", 1, None),
            create_token(TokenType::Number, "123", 1, Some(Object::Number(123.0))),
            // Missing right paren
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let result = parser.parse();

        assert!(result.is_err());
    }

    #[test]
    fn test_parse_error_invalid_expression() {
        let tokens = vec![
            // Missing expression
            create_token(TokenType::Plus, "+", 1, None),
            create_eof(1),
        ];

        let mut parser = Parser::new(tokens);
        let result = parser.parse();

        assert!(result.is_err());
    }
}
