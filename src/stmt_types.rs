use crate::Token;
use crate::{expr_types::Expr, runtime_error::RuntimeError};

/// Represents the different types of statements in the abstract syntax tree (AST).
///
/// The `Stmt` enum defines the nodes of the statement tree generated by the parser.
#[derive(Debug, Clone)]
pub enum Stmt {
    /// Represents a expresion (literal, grouping, unary or binary)
    Expression(Expr),
    /// Print Statment
    /// (Is classified as statment so the program has a print statement to work with as all the
    /// features are being implemented)
    Print(Expr),
    Var(VarStmt),
    Block(Vec<Stmt>),
}

/// Defines the visitor trait for calling the `Stmt` type.
///
/// Types that implement this trait can visit each type of statement defined by the language.
/// This is a key component of the Visitor pattern, used for operations like
/// interpretation or static analysis.
///
/// The type parameter `T` represents the return type of the visitor methods.
pub trait StmtVisitor<T> {
    fn visit_expr_stmt(&mut self, stmt: &mut Expr) -> Result<T, RuntimeError>;
    fn visit_print_stmt(&mut self, stmt: &mut Expr) -> Result<T, RuntimeError>;
    // need to borrow here as mutable because we have modifiy the environment
    fn visit_var_stmt(&mut self, stmt: &mut VarStmt) -> Result<T, RuntimeError>;
    fn visit_block_stmt(&mut self, stmt: &mut Vec<Stmt>) -> Result<T, RuntimeError>;
}

impl Stmt {
    pub fn evaluate<T>(&mut self, visitor: &mut dyn StmtVisitor<T>) -> Result<T, RuntimeError> {
        match self {
            Stmt::Expression(expr) => visitor.visit_expr_stmt(expr),
            Stmt::Print(print_stmt) => visitor.visit_print_stmt(print_stmt),
            Stmt::Var(var_stmt) => visitor.visit_var_stmt(var_stmt),
            Stmt::Block(block_stmt) => visitor.visit_block_stmt(block_stmt),
        }
    }
}

#[derive(Debug, Clone)]
pub struct VarStmt {
    pub name: Token,
    pub initializer: Option<Expr>,
}
