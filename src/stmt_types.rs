use crate::Token;
use crate::{expr_types::Expr, runtime_error::RuntimeError};

/// Represents the different types of statements in the abstract syntax tree (AST).
///
/// The `Stmt` enum defines the nodes of the statement tree generated by the parser.
#[derive(Debug, Clone)]
pub enum Stmt {
    /// Represents a expresion (literal, grouping, unary or binary)
    Expression(Expr),
    /// Print Statment
    /// (Is classified as statment so the program has a print statement to work with as all the
    /// features are being implemented)
    Print(Expr),
    Var(VarStmt),
    /// Respresents a block as a list of other statements
    Block(Vec<Stmt>),
    If(IfStmt),
    While(WhileStmt),
    Function(FunctionStmt),
}

/// Defines the visitor trait for calling the `Stmt` type.
///
/// Types that implement this trait can visit each type of statement defined by the language.
/// This is a key component of the Visitor pattern, used for operations like
/// interpretation or static analysis.
///
/// The type parameter `T` represents the return type of the visitor methods.
pub trait StmtVisitor<T> {
    fn visit_expr_stmt(&mut self, stmt: &mut Expr) -> Result<T, RuntimeError>;
    fn visit_print_stmt(&mut self, stmt: &mut Expr) -> Result<T, RuntimeError>;
    fn visit_var_stmt(&mut self, stmt: &mut VarStmt) -> Result<T, RuntimeError>;
    fn visit_block_stmt(&mut self, stmt: &mut Vec<Stmt>) -> Result<T, RuntimeError>;
    fn visit_if_stmt(&mut self, stmt: &mut IfStmt) -> Result<T, RuntimeError>;
    fn visit_while_stmt(&mut self, stmt: &mut WhileStmt) -> Result<T, RuntimeError>;
    fn visit_function_stmt(&mut self, stmt: &mut FunctionStmt) -> Result<T, RuntimeError>;
}

impl Stmt {
    /// function to evaluate each kind of 'Stmt' and return the result as 'T'
    pub fn evaluate<T>(&mut self, visitor: &mut dyn StmtVisitor<T>) -> Result<T, RuntimeError> {
        match self {
            Stmt::Expression(expr) => visitor.visit_expr_stmt(expr),
            Stmt::Print(print_stmt) => visitor.visit_print_stmt(print_stmt),
            Stmt::Var(var_stmt) => visitor.visit_var_stmt(var_stmt),
            Stmt::Block(block_stmt) => visitor.visit_block_stmt(block_stmt),
            Stmt::If(if_stmt) => visitor.visit_if_stmt(if_stmt),
            Stmt::While(while_stmt) => visitor.visit_while_stmt(while_stmt),
            Stmt::Function(function_stmt) => visitor.visit_function_stmt(function_stmt),
        }
    }
}

#[derive(Debug, Clone)]
pub struct VarStmt {
    /// The token representing the variable's name.
    pub name: Token,
    /// An optional expression that provides the initial value for the variable.
    pub initializer: Option<Expr>,
}

#[derive(Debug, Clone)]
pub struct IfStmt {
    /// The expression that determines whether the `then_branch` or `else_branch` is executed.
    pub condition: Expr,
    /// The statement to be executed if the `condition` is true.
    pub then_branch: Box<Stmt>,
    /// An optional statement to be executed if the `condition` is false.
    pub else_branch: Option<Box<Stmt>>,
}

#[derive(Debug, Clone)]
pub struct WhileStmt {
    /// The expression that determines whether the loop continues to execute.
    pub condition: Expr,
    /// The statement to be repeatedly executed as long as the `condition` is true.
    pub body: Box<Stmt>,
}

#[derive(Debug, Clone)]
pub struct FunctionStmt {
    pub name: Token,
    pub params: Vec<Token>,
    pub body: Vec<Stmt>,
}
